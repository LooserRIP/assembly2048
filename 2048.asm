;  _   _ ___   ____  _   _ __  __ _   _ _     ___ _  __
; | | | |_ _| / ___|| | | |  \/  | | | | |   |_ _| |/ /
; | |_| || |  \___ \| |_| | |\/| | | | | |    | || ' / 
; |  _  || |   ___) |  _  | |  | | |_| | |___ | || . \ 
; |_| |_|___| |____/|_| |_|_|  |_|\___/|_____|___|_|\_\
IDEAL
MODEL small
STACK 100h
SEGMENT ScreenBuffer PUBLIC
	buffer db (320*200) dup(0)
ENDS ScreenBuffer

DATASEG
	;   ____                _              _       
	;  / ___|___  _ __  ___| |_ __ _ _ __ | |_ ___ 
	; | |   / _ \| '_ \/ __| __/ _` | '_ \| __/ __|
	; | |__| (_) | | | \__ \ || (_| | | | | |_\__ \
	;  \____\___/|_| |_|___/\__\__,_|_| |_|\__|___/
	constant_framesToShowGameOver equ 1000
	constant_framesToShowStuckBlocks equ 300
	constant_framesPerGameOverFrame equ 1
	constant_animationTotalFrames equ 64
	constant_animationStopAtFrame equ 64
	constant_mergeScreenshakeFrame equ 1
	constant_characterSpacing equ 3
	constant_amountOfButtons equ 4

	nullbyte equ 0ffh
	nullword equ 0ffffh
	boolFalse equ 0
	boolTrue equ 1

	gamemodeMainMenu equ 0
	gamemodePlaying equ 1
	gamemodeDead equ 2
	gamemodePause equ 3
	;  ___       _                        _ 
	; |_ _|_ __ | |_ ___ _ __ _ __   __ _| |
	;  | || '_ \| __/ _ \ '__| '_ \ / _` | |
	;  | || | | | ||  __/ |  | | | | (_| | |
	; |___|_| |_|\__\___|_|  |_| |_|\__,_|_|
	;
	internal_tempElement db 50 dup(0)
	internal_testCounter dw 0

	internal_primes dw 6e81h,78adh,2b27h,0a535h,266fh,88cfh,9e47h,241h,0c86bh,5e57h,7051h,0d3dh,0a457h,0e969h,0a5c5h,0fc41h,0c461h,0e6c5h
		   dw 5fbdh,59f3h,5dfdh,2da9h,9debh,0d187h,3d1fh,8143h,2e37h,6011h,8f2dh,0db31h,50c9h,155fh,933dh,0c5fbh,0dac3h,0c3e9h,5b49h
		   dw 6d2bh,417bh,2149h,4d81h,5e39h,3fbfh,0df69h,103dh,9287h,1c55h,0e183h,4badh,0a0f1h,0a5ddh,588dh,0bbdbh,905h,76f1h,0adf5h
		   dw 19cfh,73bdh,4e9bh,0b82dh,3275h,6557h,7211h,2cffh,0dc9fh,8e01h,0f503h,0cdf1h,0fc29h,2f83h,0fbf3h,0a64bh,9da9h,2063h,329fh
		   dw 9a61h,0d081h,6421h,6c59h,4f2dh,793fh,21d7h,773h,2813h,70f9h,238fh,0dd39h,0d343h,0e95h,22e5h,0dc61h,0f269h,9127h,3f1h,0d159h
		   dw 0b3h,26bh,65e3h,0bd8fh,276dh,2e7fh,0cfc5h,0e171h,74e1h,0d42fh,1343h,55f3h,0c1e7h,0e98fh,0b9ddh,7bebh,97b7h,48efh,2aebh,98f9h
		   dw 4f63h,7673h,410bh,80cbh,2a9dh,239h,6f79h,2e3h,949fh,143bh,0fdf3h,8021h,0dd7dh,77b3h,8eabh,52e5h,0afa3h,27efh,230bh,0b3a5h,3173h
		   dw 1da5h,8d0dh,0f93bh,2029h,2419h,66cdh,2135h,40fh,0ac1h,5f77h,0f485h,0baa3h,0d315h,0f0d3h,4043h,0fb93h,0bcb9h,0f8ddh,0d945h,0e59h
		   dw 2c5h,0a67h,3a1h,7703h,5c6fh,4d8dh,1b83h,110bh,8231h,135dh,616fh,40f9h,0bb9h,9f7h,259fh,0f79dh,8bd5h,599h,86c5h,0fa3fh,9fc1h,9733h
		   dw 0f7bdh,4be9h,0abf5h,8d41h,0ca7fh,0b5h,0a597h,0e1bfh,0f257h,0efh,96fdh,47b1h,0a1a5h,0aba7h,93efh,6a91h,0eacbh,2351h,1e95h,2287h,0e5h,0d661h
    internal_primeCounter dw 0

	internal_shouldSpawnBlock db boolFalse

    lists_alloc db 5000 dup(nullbyte)
	lists_info db 300 dup (00h)
	lists_amount dw 0
	lists_offset dw 0

	listID_particles dw nullword
	listID_animation dw nullword
	listOffset_animation dw nullword

	internal_blockSpriteOffsets dw offset sprite_2, offset sprite_4, offset sprite_8, offset sprite_16, offset sprite_32, offset sprite_64, offset sprite_128, offset sprite_256, offset sprite_512, offset sprite_1024, offset sprite_2048
	internal_backgroundMaskOffsets dw 3 dup(offset mask_background_two), 3 dup(offset mask_background_four), 3 dup(offset mask_background_eight), 3 dup(offset mask_background_exponent), offset mask_background_plus, offset mask_background_smiley, offset mask_background_wtf, offset mask_background_shmulik
	internal_fontOffsets dw 48 dup (mask_background_wtf)
						 dw offset mask_number_0, offset mask_number_1, offset mask_number_2, offset mask_number_3, offset mask_number_4, offset mask_number_5, offset mask_number_6, offset mask_number_7, offset mask_number_8, offset mask_number_9
						 dw 70 dup (mask_background_wtf)
	internal_buttonIconOffsets dw offset mask_icon_restart, offset mask_icon_mainmenu, offset mask_icon_shake, offset mask_icon_animation


	internal_keyActions dw 256 dup(nullword)
	internal_mouseActions dw (5*20) dup(nullword)
	internal_mouseActionsPointer dw 0
	internal_activeMouseActions dw 20 dup(boolFalse)
	internal_buttonToggles dw constant_amountOfButtons dup(boolFalse)

	internal_curveCache db (12*64) dup(nullbyte)

	internal_displayTest db '1932', 10 dup (0), 1 ; 1 stops the conversion immediately
	internal_gameOverFrameAddCounter dw 0
	;internal_totalRectMax dw 1

	; Mouse stuff
	internal_mouseLeftClick db boolFalse
	internal_mouseLeftClickFirst db boolFalse
	internal_mouseRightClick db boolFalse
	internal_mouseRightClickFirst db boolFalse
	internal_mouseX dw nullword
	internal_mouseY dw nullword
	internal_movedMouse db boolFalse


	;  ____                _           _             
	; |  _ \ ___ _ __   __| | ___ _ __(_)_ __   __ _ 
	; |  _ <  __/ | | | (_| |  __/ |  | | | | | (_| |
	; |_| \_\___|_| |_|\__,_|\___|_|  |_|_| |_|\__, |
	;                                          |___/ 
	
	; Misc
	rendering_animationFrame dw nullword
	rendering_mergedScore db boolFalse

	rendering_gameOverFrame dw 0

	rendering_shake_framesLeft dw nullword
	rendering_shake_priority dw 0
	rendering_shake_strength dw 0
	rendering_shake_xOffset dw 0
	rendering_shake_yOffset dw 0

	rendering_blockSpawnColors dw 9, 14, 19, 10 dup (60)


	; Palettes
	rendering_palette dq 2c2b47394f3f2b38h,3d262553333247h,8f8a0b655e0b554eh,195fb9e1309baf0eh,0e8572cbb4c217e46h,22195f8787f07c57h,7de82c4bbb21267eh,8e394e7287bdf057h,65d4f641a7cf3f6bh,89503d6e4f91faf8h,0c66eedba4ac69a44h,748944556e3da6fch,0fca690ed6e66c64ah,31bf9b2fab712fd0h,0eeff71e2e230c0bbh,75bbd1648aa85085h,63ffb5f6f48bdcf4h,526bcc374a952431h,0adad7f7f7f738ceeh,0eac4c4c4b7aca8adh,9ddb097bd2eaeah,0e1fd60cef80aaaf5h,76aaffff00d4ff50h,647dc1574776553ah,0ddffa0cfff5e5cc1h,0ffa6eeff3d9eff49h,0a95748351d1cffffh,269b68413fbf8378h,2b6e31006a42d251h,90745f8b6a547e4ch,9f9289h,66 dup(0h)

	sprite_2 dw 2 dup(20h),0h,902h,14 dup(909h),209h,15 dup(909h),708h,909h,809h,13 dup(808h),707h,909h,14 dup(808h),707h,909h,5 dup(808h),3 dup(505h),805h,5 dup(808h),707h,909h,4 dup(808h),505h,605h,3 dup(606h),805h,4 dup(808h),707h,909h,3 dup(808h),508h,605h,5 dup(606h),4 dup(808h),707h,909h,3 dup(808h),505h,2 dup(606h),2 dup(808h),2 dup(606h),806h,3 dup(808h),707h,909h,3 dup(808h),605h,606h,4 dup(808h),606h,806h,3 dup(808h),707h,909h,3 dup(808h),608h,806h,4 dup(808h),605h,606h,3 dup(808h),707h,909h,9 dup(808h),605h,606h,3 dup(808h),707h,909h,9 dup(808h),605h,606h,3 dup(808h),707h,909h,9 dup(808h),605h,606h,3 dup(808h),707h,909h,9 dup(808h),605h,606h,3 dup(808h),707h,909h,8 dup(808h),508h,605h,806h,3 dup(808h),707h,909h,8 dup(808h),505h,606h,806h,3 dup(808h),707h,909h,7 dup(808h),508h,605h,606h,4 dup(808h),707h,909h,7 dup(808h),505h,606h,806h,4 dup(808h),707h,909h,6 dup(808h),508h,605h,606h,5 dup(808h),707h,909h
             dw 6 dup(808h),505h,606h,806h,5 dup(808h),707h,909h,5 dup(808h),508h,605h,606h,6 dup(808h),707h,909h,5 dup(808h),505h,606h,806h,6 dup(808h),707h,909h,4 dup(808h),508h,605h,606h,7 dup(808h),707h,909h,4 dup(808h),505h,606h,806h,7 dup(808h),707h,909h,3 dup(808h),508h,605h,606h,8 dup(808h),707h,909h,3 dup(808h),505h,2 dup(606h),4 dup(505h),805h,3 dup(808h),707h,909h,3 dup(808h),605h,7 dup(606h),3 dup(808h),707h,909h,3 dup(808h),608h,7 dup(606h),3 dup(808h),707h,909h,14 dup(808h),707h,909h,13 dup(808h),708h,707h,809h,15 dup(707h),702h,14 dup(707h),207h,4 dup(0h)
    sprite_4 dw 2 dup(20h),0h,0e02h,14 dup(0e0eh),20eh,15 dup(0e0eh),0c0dh,0e0eh,0d0eh,13 dup(0d0dh),0c0ch,0e0eh,14 dup(0d0dh),0c0ch,0e0eh,7 dup(0d0dh),0a0dh,0a0ah,5 dup(0d0dh),0c0ch,0e0eh,7 dup(0d0dh),0a0ah,0b0bh,0d0bh,4 dup(0d0dh),0c0ch,0e0eh,6 dup(0d0dh),0a0dh,0b0ah,0b0bh,0d0bh,4 dup(0d0dh),0c0ch,0e0eh,6 dup(0d0dh),0a0dh,3 dup(0b0bh),4 dup(0d0dh),0c0ch,0e0eh,6 dup(0d0dh),0a0ah,3 dup(0b0bh),4 dup(0d0dh),0c0ch,0e0eh,5 dup(0d0dh),0a0dh,0b0ah,0b0bh,0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,5 dup(0d0dh),0a0ah,0b0bh,0d0bh,0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,5 dup(0d0dh),0b0ah,0b0bh,0d0dh,0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,4 dup(0d0dh),0a0dh,0b0ah,0b0bh,0d0dh,0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,4 dup(0d0dh),0a0ah,0b0bh,0d0bh,0d0dh,0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,3 dup(0d0dh),0a0dh,0b0ah,0b0bh,2 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,3 dup(0d0dh),0a0dh,2 dup(0b0bh),2 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh)
             dw 0c0ch,0e0eh,3 dup(0d0dh),0a0ah,0b0bh,0d0bh,2 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,2 dup(0d0dh),0a0dh,0b0ah,0b0bh,3 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,2 dup(0d0dh),0a0ah,2 dup(0b0bh),3 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,2 dup(0d0dh),0b0ah,2 dup(0b0bh),3 dup(0a0ah),0b0ah,0b0bh,0a0ah,0d0ah,2 dup(0d0dh),0c0ch,0e0eh,2 dup(0d0dh),0b0ah,8 dup(0b0bh),0d0bh,2 dup(0d0dh),0c0ch,0e0eh,2 dup(0d0dh),0b0dh,9 dup(0b0bh),2 dup(0d0dh),0c0ch,0e0eh,3 dup(0d0dh),8 dup(0b0bh),0d0bh,2 dup(0d0dh),0c0ch,0e0eh,8 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,8 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,8 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,8 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,8 dup(0d0dh),0b0ah,0b0bh,4 dup(0d0dh),0c0ch,0e0eh,14 dup(0d0dh),0c0ch,0e0eh,13 dup(0d0dh),0c0dh,0c0ch,0d0eh,15 dup(0c0ch),0c02h,14 dup(0c0ch),20ch,4 dup(0h)
    sprite_8 db 32,0,32,3 dup(0),2,30 dup(19),2,30 dup(19),18,17,3 dup(19),27 dup(18),2 dup(17),2 dup(19),28 dup(18),2 dup(17),2 dup(19),10 dup(18),7 dup(15),11 dup(18),2 dup(17),2 dup(19),8 dup(18),3 dup(15),7 dup(16),15,9 dup(18),2 dup(17),2 dup(19),7 dup(18),2 dup(15),11 dup(16),8 dup(18),2 dup(17),2 dup(19),6 dup(18),2 dup(15),13 dup(16),7 dup(18),2 dup(17),2 dup(19),6 dup(18),15,4 dup(16),7 dup(18),4 dup(16),6 dup(18),2 dup(17),2 dup(19),6 dup(18),15,3 dup(16),8 dup(18),15,3 dup(16),6 dup(18),2 dup(17),2 dup(19),6 dup(18),15,3 dup(16),8 dup(18),15,3 dup(16),6 dup(18),2 dup(17),2 dup(19),6 dup(18),15,3 dup(16),8 dup(18),15,3 dup(16),6 dup(18),2 dup(17),2 dup(19),6 dup(18),15,3 dup(16),8 dup(18),15,3 dup(16),6 dup(18),2 dup(17),2 dup(19),7 dup(18),4 dup(16),5 dup(18),3 dup(15),3 dup(16),6 dup(18),2 dup(17),2 dup(19),8 dup(18),4 dup(16),5 dup(15),4 dup(16),7 dup(18),2 dup(17),2 dup(19),9 dup(18)
             db 11 dup(16),8 dup(18),2 dup(17),2 dup(19),7 dup(18),3 dup(15),9 dup(16),15,8 dup(18),2 dup(17),2 dup(19),6 dup(18),2 dup(15),5 dup(16),3 dup(18),5 dup(16),7 dup(18),2 dup(17),2 dup(19),6 dup(18),15,4 dup(16),7 dup(18),4 dup(16),6 dup(18),2 dup(17),2 dup(19),5 dup(18),2 dup(15),3 dup(16),9 dup(18),3 dup(16),6 dup(18),2 dup(17),2 dup(19),5 dup(18),15,3 dup(16),10 dup(18),15,3 dup(16),5 dup(18),2 dup(17),2 dup(19),5 dup(18),15,3 dup(16),10 dup(18),15,3 dup(16),5 dup(18),2 dup(17),2 dup(19),5 dup(18),15,3 dup(16),10 dup(18),15,3 dup(16),5 dup(18),2 dup(17),2 dup(19),6 dup(18),3 dup(16),9 dup(18),2 dup(15),3 dup(16),5 dup(18),2 dup(17),2 dup(19),6 dup(18),15,3 dup(16),15,5 dup(18),3 dup(15),3 dup(16),6 dup(18),2 dup(17),2 dup(19),7 dup(18),5 dup(16),5 dup(15),5 dup(16),6 dup(18),2 dup(17),2 dup(19),8 dup(18),13 dup(16),7 dup(18),2 dup(17),2 dup(19),10 dup(18),9 dup(16),9 dup(18),2 dup(17)
             db 2 dup(19),28 dup(18),2 dup(17),2 dup(19),27 dup(18),3 dup(17),19,18,30 dup(17),2,30 dup(17),2,8 dup(0)
    sprite_16 dd 200020h,18020000h,7 dup(18181818h),18180218h,7 dup(18181818h),18181617h,17171718h,6 dup(17171717h),18181616h,7 dup(17171717h),18181616h,7 dup(17171717h),18181616h,7 dup(17171717h),18181616h,7 dup(17171717h),18181616h,17171717h,14171717h,17171714h,17171717h,14141717h,17141414h,17171717h,18181616h,17171717h,14141414h,17171515h,17171717h,15141414h,15151515h,17171717h,18181616h,14171717h,15151514h,17171515h,14171717h,15151514h,15151515h,17171715h,18181616h,14141717h,15151515h,17171515h,14141717h,17151515h,17171717h,17171715h,18181616h,15171717h,14171515h,17171515h,15141417h,17171515h,2 dup(17171717h),18181616h,17171717h,14171717h,17171515h,15151417h,17171715h,2 dup(17171717h),18181616h,17171717h,14171717h,17171515h,15151417h,3 dup(17171717h),18181616h,17171717h,14171717h,17171515h,15151417h,14141417h,17141414h,17171717h,18181616h,17171717h,14171717h,17171515h,15151417h
              dd 15151414h,15151515h,17171717h,18181616h,17171717h,14171717h,17171515h,15151417h,2 dup(15151515h),17171715h,18181616h,17171717h,14171717h,17171515h,15151417h,17171515h,15171717h,17171515h,18181616h,17171717h,14171717h,17171515h,15151417h,17171717h,14171717h,17171515h,18181616h,17171717h,14171717h,17171515h,15151417h,17171717h,14171717h,17171515h,18181616h,17171717h,14171717h,17171515h,15151417h,17171717h,14171717h,17171515h,18181616h,17171717h,14171717h,17171515h,15151417h,17171717h,14171717h,17171515h,18181616h,17171717h,14171717h,17171515h,15151717h,17171715h,14141717h,17171515h,18181616h,17171717h,14171717h,17171515h,15171717h,14141515h,15141414h,17171515h,18181616h,17171717h,14171717h,17171515h,17171717h,2 dup(15151515h),17171715h,18181616h,2 dup(17171717h),17171515h,17171717h,15151517h,15151515h,17171717h,18181616h,7 dup(17171717h),18181616h,7 dup(17171717h),18181616h
              dd 7 dup(17171717h),18181616h,6 dup(17171717h),16171717h,17181616h,7 dup(16161616h),16021616h,7 dup(16161616h),216h,2 dup(0h)
    sprite_32 dw 2 dup(20h),0h,1d02h,14 dup(1d1dh),21dh,15 dup(1d1dh),1b1ch,1d1dh,1c1dh,13 dup(1c1ch),1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,1c1ch,191ch,2 dup(1919h),1c19h,3 dup(1c1ch),191ch,2 dup(1919h),3 dup(1c1ch),1b1bh,1d1dh,1c1ch,1919h,3 dup(1a1ah),1c19h,1c1ch,191ch,1919h,2 dup(1a1ah),191ah,2 dup(1c1ch),1b1bh,1d1dh,191ch,1a19h,4 dup(1a1ah),1c1ch,191ch,4 dup(1a1ah),1c1ah,1c1ch,1b1bh,1d1dh,1c1ch,1a1ah,1c1ah,2 dup(1c1ch),1a1ah,1c1ah,1c1ch,1a1ah,2 dup(1c1ch),1a1ch,1a1ah,1c1ch,1b1bh,1d1dh,5 dup(1c1ch),1a19h,1c1ah,4 dup(1c1ch),191ch,1a1ah,1c1ch,1b1bh,1d1dh,5 dup(1c1ch),1a19h,1c1ah,4 dup(1c1ch),191ch,1a1ah,1c1ah,1b1bh,1d1dh,5 dup(1c1ch),1a19h,1c1ah,4 dup(1c1ch),191ch,1a1ah,1c1ah,1b1bh,1d1dh,4 dup(1c1ch),1919h,1a19h,1c1ah,4 dup(1c1ch),1919h,1a1ah,1c1ch,1b1bh,1d1dh,2 dup(1c1ch),2 dup(1919h),1a19h,1a1ah,5 dup(1c1ch),1a19h,1a1ah,1c1ch,1b1bh,1d1dh
              dw 2 dup(1c1ch),1a19h,2 dup(1a1ah),1c1ah,4 dup(1c1ch),191ch,1a19h,1c1ah,1c1ch,1b1bh,1d1dh,2 dup(1c1ch),1a1ch,3 dup(1a1ah),4 dup(1c1ch),1919h,1a1ah,1c1ah,1c1ch,1b1bh,1d1dh,5 dup(1c1ch),1a1ah,1c1ah,2 dup(1c1ch),191ch,1a19h,1a1ah,2 dup(1c1ch),1b1bh,1d1dh,5 dup(1c1ch),1a1ch,1a1ah,2 dup(1c1ch),1919h,1a1ah,1c1ah,2 dup(1c1ch),1b1bh,1d1dh,5 dup(1c1ch),191ch,1a1ah,1c1ch,191ch,1a19h,1a1ah,3 dup(1c1ch),1b1bh,1d1dh,5 dup(1c1ch),1919h,1a1ah,1c1ch,1919h,1a1ah,1c1ah,3 dup(1c1ch),1b1bh,1d1dh,191ch,1c19h,3 dup(1c1ch),1a19h,1a1ah,191ch,1a19h,1a1ah,4 dup(1c1ch),1b1bh,1d1dh,191ch,1a1ah,3 dup(1919h),1a19h,1c1ah,1919h,1a1ah,191ah,3 dup(1919h),1c1ch,1b1bh,1d1dh,1c1ch,5 dup(1a1ah),1c1ah,1a19h,5 dup(1a1ah),1c1ah,1b1bh,1d1dh,1c1ch,1a1ch,3 dup(1a1ah),1c1ah,1c1ch,1a1ch,5 dup(1a1ah),1c1ah,1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,14 dup(1c1ch),1b1bh,1d1dh,13 dup(1c1ch),1b1ch,1b1bh,1c1dh,15 dup(1b1bh),1b02h
              dw 14 dup(1b1bh),21bh,4 dup(0h)
    sprite_64 dd 200020h,22020000h,7 dup(22222222h),22220222h,7 dup(22222222h),22222021h,21212122h,6 dup(21212121h),22222020h,7 dup(21212121h),22222020h,7 dup(21212121h),22222020h,7 dup(21212121h),22222020h,21212121h,1e1e2121h,211e1e1eh,2 dup(21212121h),1e1e2121h,2121211eh,22222020h,21212121h,1f1e1e1eh,1f1f1f1fh,2 dup(21212121h),1f1e1e21h,21211f1fh,22222020h,1e212121h,1f1f1f1eh,1f1f1f1fh,2121211fh,21212121h,1f1f1e21h,21211f1fh,22222020h,1e1e2121h,211f1f1fh,21212121h,2121211fh,21212121h,1f1f1e1eh,21211f1fh,22222020h,1f1e1e21h,21211f1fh,2 dup(21212121h),1e212121h,1e1f1f1eh,21211f1fh,22222020h,1f1f1e21h,2121211fh,2 dup(21212121h),1e1e2121h,1e1f1f1fh,21211f1fh,22222020h,1f1f1e21h,3 dup(21212121h),1f1e2121h,1e211f1fh,21211f1fh,22222020h,1f1f1e21h,1e1e1e21h,211e1e1eh,21212121h,1f1e1e21h,1e21211fh,21211f1fh,22222020h,1f1f1e21h,1f1f1e1eh,1f1f1f1fh,21212121h,1f1f1e1eh,1e212121h,21211f1fh
              dd 22222020h,1f1f1e21h,2 dup(1f1f1f1fh),1e21211fh,1f1f1f1eh,1e212121h,21211f1fh,22222020h,1f1f1e21h,21211f1fh,1f212121h,1e211f1fh,211f1f1fh,1e212121h,21211f1fh,22222020h,1f1f1e21h,21212121h,1e212121h,1e1e1f1fh,21211f1fh,1e212121h,21211f1fh,22222020h,1f1f1e21h,21212121h,1e212121h,1f1e1f1fh,1e1e1f1fh,1e1e1e1eh,211e1f1fh,22222020h,1f1f1e21h,21212121h,1e212121h,1f1e1f1fh,3 dup(1f1f1f1fh),22222020h,1f1f1e21h,21212121h,1e212121h,1f211f1fh,3 dup(1f1f1f1fh),22222020h,1f1f2121h,2121211fh,1e1e2121h,21211f1fh,21212121h,1e212121h,21211f1fh,22222020h,1f212121h,1e1e1f1fh,1f1e1e1eh,21211f1fh,21212121h,1e212121h,21211f1fh,22222020h,21212121h,2 dup(1f1f1f1fh),2121211fh,21212121h,1e212121h,21211f1fh,22222020h,21212121h,1f1f1f21h,1f1f1f1fh,3 dup(21212121h),21211f1fh,22222020h,7 dup(21212121h),22222020h,7 dup(21212121h),22222020h,7 dup(21212121h),22222020h,7 dup(21212121h),22222020h
              dd 6 dup(21212121h),20212121h,21222020h,7 dup(20202020h),20022020h,7 dup(20202020h),220h,2 dup(0h)
    sprite_128 dd 200020h,27020000h,7 dup(27272727h),27270227h,7 dup(27272727h),27272526h,26262627h,6 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,23262626h,26262623h,23232326h,26262623h,26262626h,23232323h,26262626h,27272525h,23232326h,26262424h,24242323h,26232424h,23262626h,24242423h,26262324h,27272525h,24242323h,26262424h,24242423h,24242424h,23232626h,24242424h,26242424h,27272525h,24242426h,26262424h,26262426h,24242326h,24232626h,26262424h,26242426h,27272525h,23262626h,26262424h,26262626h,24242326h,24232626h,26262624h,26242323h,27272525h,23262626h,26262424h,26262626h,24242326h,24262626h,23232424h,26242423h,27272525h,23262626h,26262424h,26262626h,24242323h,23262626h,24242424h,26262424h,27272525h,23262626h,26262424h
               dd 23262626h,26242423h,23232626h,24242424h,26242424h,27272525h,23262626h,26262424h,23232626h,26262424h,24232626h,26262624h,26242426h,27272525h,23262626h,26262424h,24232326h,26262624h,24232626h,26262624h,26242326h,27272525h,23262626h,26262424h,24242323h,26232323h,24232626h,26262624h,26242323h,27272525h,23262626h,26262424h,24242423h,24242424h,24262626h,23232424h,26242423h,27272525h,26262626h,26262424h,24242426h,24242424h,26262624h,24242424h,26262424h,27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,7 dup(26262626h),27272525h,6 dup(26262626h),25262626h,26272525h,7 dup(25252525h),25022525h,7 dup(25252525h),225h,2 dup(0h)
    sprite_256 dd 200020h,2c020000h,7 dup(2c2c2c2ch),2c2c022ch,7 dup(2c2c2c2ch),2c2c2a2bh,2b2b2b2ch,6 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,28282b2bh,2b2b2828h,282b2b2bh,28282828h,2b2b2b28h,2828282bh,2b2b2b28h,2c2c2a2ah,2928282bh,28292929h,28282b2bh,29292929h,2b2b2929h,29292828h,2b2b2929h,2c2c2a2ah,2929282bh,29292929h,29282b29h,29292929h,282b2929h,29292928h,2b292929h,2c2c2a2ah,2b292b2bh,29282b2bh,29282b29h,2b2b2b29h,28282b2bh,2b2b2929h,2b2b2b2bh,2c2c2a2ah,2b2b2b2bh,29282b2bh,29282b29h,2b2b2b29h,29282b2bh,2b2b2b29h,2b2b2b2bh,2c2c2a2ah,2b2b2b2bh,29282b2bh,29282b29h,28282829h,29282b2bh,28282829h,2b2b2828h,2c2c2a2ah,2b2b2b2bh,2928282bh,29282b29h,29292929h,29282b29h,29292929h,2b292929h,2c2c2a2ah,2b2b2b2bh,29292828h
               dd 292b2b2bh,29292929h,29282929h,2b2b2929h,2b29292bh,2c2c2a2ah,282b2b2bh,2b292928h,2b2b2b2bh,282b2b2bh,29282929h,2b2b2b29h,2929282bh,2c2c2a2ah,28282b2bh,2b2b2929h,2b2b2b2bh,282b2b2bh,29282929h,2b2b2b29h,29292828h,2c2c2a2ah,2928282bh,28282829h,2 dup(28282b2bh),292b2929h,28282829h,29292928h,2c2c2a2ah,2929282bh,29292929h,29282b29h,29282829h,2b2b2929h,29292929h,2b292929h,2c2c2a2ah,29292b2bh,29292929h,292b2929h,29292929h,2b2b2b29h,2929292bh,2b2b2929h,2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,7 dup(2b2b2b2bh),2c2c2a2ah,6 dup(2b2b2b2bh),2a2b2b2bh,2b2c2a2ah,7 dup(2a2a2a2ah),2a022a2ah,7 dup(2a2a2a2ah),22ah,2 dup(0h)
    sprite_512 dd 200020h,30020000h,7 dup(30303030h),30300230h,7 dup(30303030h),30302e2fh,2f2f2f30h,6 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,2d2f2f2fh,2d2d2d2dh,2f2f2f2dh,2f2d2d2fh,2d2f2f2fh,2f2d2d2dh,2f2f2f2fh,30302e2eh,2d2d2f2fh,2e2e2e2eh,2f2f2e2eh,2e2e2d2dh,2d2d2f2fh,2e2e2e2eh,2f2f2f2dh,30302e2eh,2e2d2f2fh,2e2e2e2eh,2d302e2eh,2e2e2e2dh,2e2d2f30h,2e2e2e2eh,2f2f2e2eh,30302e2eh,2e2d2f2fh,3030302eh,2f303030h,2e2e2e2eh,2e2f2f30h,2d303030h,2f302e2eh,30302e2eh,2e2d2f2fh,2f2f3030h,2f2f2f2fh,2e2e2d2fh,2f2f2f30h,2d2f2f30h,2f302e2eh,30302e2eh,2e2d2f2fh,2d2d2d2dh,2f2f2f2fh,2e2e2d2fh,2f2f2f30h,2d2f2f2fh,2f302e2eh,30302e2eh,2e2d2f2fh,2e2e2e2eh,2f2f2f2eh,2e2e2d2fh,2f2f2f30h,2d2d2f2fh,2f302e2eh,30302e2eh,2e2f2f2fh,2e2e2e2eh,2f2f2e2eh,2e2e2d2fh,2f2f2f30h
               dd 2e2d2d2fh,2f30302eh,30302e2eh,2f2f2f2fh,2d303030h,2f302e2eh,2e2e2d2fh,2f2f2f30h,2e2e2d2dh,2f2f3030h,30302e2eh,2f2f2f2fh,2d2f2f2fh,2f302e2eh,2e2e2d2fh,2d2f2f30h,302e2e2dh,2f2f2f30h,30302e2eh,2 dup(2d2d2f2fh),2f302e2eh,2e2e2d2fh,2d2d2f30h,2d2d2e2eh,2f2f2f2dh,30302e2eh,2e2d2f2fh,2e2d2d2eh,2f302e2eh,2e2e2d2fh,2e2d2f30h,2e2e2e2eh,2f2f2e2eh,30302e2eh,2e2f2f2fh,2e2e2e2eh,2f30302eh,2e2e2f2fh,2e2f2f30h,2e2e2e2eh,2f2e2e2eh,30302e2eh,2f2f2f2fh,30303030h,2f2f3030h,302f2f2fh,2f2f2f30h,2 dup(30303030h),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,7 dup(2f2f2f2fh),30302e2eh,6 dup(2f2f2f2fh),2e2f2f2fh,2f302e2eh,7 dup(2e2e2e2eh),2e022e2eh,7 dup(2e2e2e2eh),22eh,2 dup(0h)
    sprite_1024 dq 3502000000200020h,3 dup(3535353535353535h),3535023535353535h,3 dup(3535353535353535h),3535323435353535h,3334343434343435h,3334343434343433h,3434343434333333h,3535323234343434h,3333333434343434h,3333343434343131h,3434343331313131h,3535323234343434h,3131333334343434h,3133333434313131h,3434313131313131h,3535323234343434h,3131313434343434h,3131333435313133h,3435313135353531h,3535323234343434h,3535343434343434h,3131333435313133h,3431313334343535h,3535323234343434h,3434343434343434h,3131333435313133h,3531313334343435h,3535323234343434h,3434343434343434h,3131333435313133h,3531313334343435h,3535323234343434h,3434343434343434h,3131333435313133h,3531313334343435h,3535323234343434h,3434343434343434h,3131333435313133h,3531313334343435h,3535323234343434h,3434343434343434h,3131333435313133h,3531313334343435h,3535323234343434h,3434343434343434h
                dq 3131333435313133h,3531313333343435h,3535323234343434h,3434343434343434h,3131343435313133h,3531313133333331h,3535323234343434h,3434343434343434h,3134343435313133h,3535313131313131h,3535323234343434h,3434343434343434h,3434343435313134h,3435353131313131h,3535323234343434h,3333333434343434h,3434343435353333h,3434353535353534h,3535323234343434h,3131333334343434h,3434343433313131h,3434313131333434h,3535323234343434h,3131313334343434h,3434343131313131h,3435313131333334h,3535323234343434h,3535313434343434h,3434353131333535h,3435313131313333h,3535323234343434h,3435343434343434h,3334353131333434h,3435313133313133h,3535323234343434h,3434343434343434h,3334353131333434h,3435313133313131h,3535323234343434h,3434343434343434h,3333353131333334h,3435313133353131h,3535323234343434h,3434343434343434h,3133333531313333h,3435313133353531h,3535323234343434h
                dq 3334343434343434h,3131333535313133h,3433313133333331h,3535323234343434h,3333343434343434h,3131333435353131h,3131313131313131h,3535323234343434h,3133333334343434h,3131343434353531h,3131313131313131h,3535323234343435h,3131313334343434h,3534343433333333h,3535313133353535h,3535323234343435h,3131313334343434h,3434343131313131h,3435313133343434h,3535323234343434h,3131313434343434h,3434313131313131h,3435313134343434h,3435323232343434h,3 dup(3232323232323232h),3202323232323232h,3 dup(3232323232323232h),23232323232h,2 dup(0h)
    sprite_2048 dq 3c02000000200020h,3 dup(3c3c3c3c3c3c3c3ch),3c3c023c3c3c3c3ch,3 dup(3c3c3c3c3c3c3c3ch),3c3c373b3c3c3c3ch,3636363b3b3b3b3ch,3b3b3b3b3b3b3636h,3b3b3b3b36363636h,3c3c37373b3b3b3bh,393936363b3b3b3bh,363b3b3b36393939h,3b3b363939393936h,3c3c37373b3b3b3bh,383839363b3b3b3bh,36363b3838383838h,3b38383838383839h,3c3c37373b3b3b3bh,3a3a383b3b3b3b3bh,39363a3839363a3ah,3a38383a3a3a3838h,3c3c37373b3b3b3bh,3b3a3b3b3b3b3b3bh,39363a3839363b3bh,3839363b3b3a3a38h,3c3c37373b3b3b3bh,3b3b3b3b3b3b3b3bh,39363a3839363b3bh,3839363b3b3b3a38h,3c3c37373b3b3b3ah,3b3b3b3b3b3b3b3bh,39363a383936363bh,3839363b3b3b3a38h,3c3c37373b3b3b3ah,3b3b3b3b3b3b3b3bh,39363a3a38393636h,3839363b3b3b3a38h,3c3c37373b3b3b3ah,363b3b3b3b3b3b3bh,39363b3a3a383936h,3839363b3b3b3a38h,3c3c37373b3b3b3ah,36363b3b3b3b3b3bh,39363b3b3a3a3839h,3839363b3b3b3a38h,3c3c37373b3b3b3ah,393636363b3b3b3bh
                dq 39363b3b3b3a3a38h,383936363b3b3a38h,3c3c37373b3b3b3ah,383939363b3b3b3bh,393b3b3b36363636h,3838393636363838h,3c3c37373b3b3b3ah,383839363b3b3b3bh,3b3b3b3838383838h,3a38383939393838h,3c3c37373b3b3b3ah,3838393b3b3b3b3bh,3b3b383838383838h,3a3a38383838383bh,3c3c37373b3b3b3bh,3a3a3b3b3b3b3b3bh,3b3a3a3a3636363ah,3b3a363636363636h,3c3c37373b3b3b3bh,3b3b3b3b3b3b3b3bh,363b3b393939363bh,3b39393939393936h,3c3c37373b3b3b3bh,3b3b3b3b3b3b3b3bh,363b3a3838393636h,3838383838383839h,3c3c37373b3b3b3bh,363b3b3b3b3b3b3bh,363b3a3838383936h,3839363a3a3a3839h,3c3c37373b3b3b3ah,36363b3b3b3b3b3bh,363b3a3839363839h,3839363b3b3a3839h,3c3c37373b3b3b3ah,39363b3b3b3b3b3bh,363b3a3839363838h,3839363636363839h,3c3c37373b3b3b3ah,3936363b3b3b3b3bh,3b3b3a3839363a38h,3838393939393839h,3c3c37373b3b3b3ah,383936363b3b3b3bh,363b3a3839363a3ah,3a38383838383836h,3c3c37373b3b3b3ah
                dq 383839363b3b3b3bh,36363a3839363636h,3838383a3a3a3839h,3c3c37373b3b3b3bh,383839363b3b3b3bh,3936383839393939h,38383b3b3b3a3a38h,3c3c37373b3b3b3ah,3838393b3b3b3b3bh,3936383838383838h,3836363b3b3b3a38h,3c3c37373b3b3b3ah,3a3a3b3b3b3b3b3bh,393a3a3839363a3ah,3839363636363838h,3c3c37373b3b3b3bh,3b3b3b3b3b3b3b3bh,3b3b3a3838363b3bh,3838393939393838h,3c3c37373b3b3b3ah,3b3b3b3b3b3b3b3bh,3b3b3a38383b3b3bh,3a3838383838383bh,3b3c3737373b3b3ah,3 dup(3737373737373737h),3702373737373737h,3 dup(3737373737373737h),23737373737h,2 dup(0h)
	sprite_stuckBlock db 32,0,32,0,1,0,255,30 dup(73),255,3 dup(73),26 dup(255),73,3,4,2 dup(73),28 dup(255),2 dup(4),73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,73,30 dup(255),4,2 dup(73),28 dup(255),2 dup(4),73,3,4,26 dup(255),3 dup(4),255,30 dup(4),255,8 dup(0)


	sprite_cursor dq 0ff450001000a0007h,0ff4545ffffffffffh,0ff454145ffffffffh,0ff45414345ffffffh,0ff4543434145ffffh,0ff454343434345ffh,4545434343434345h,4534344545454343h,3434ffff34343445h,0ffffffffh,2 dup(0h)
	sprite_button_x dq 0eff0001000f0010h,0ffffffffffffff0eh,0d0eff0b0e0effffh,0ffffffffffff0e0dh,0d0e0b0c0d0d0effh,0ffffffffff0e0d0dh,0eff0b0c0d0d0d0eh,0effffff0e0d0d0dh,0ffffff0b0c0d0d0dh,0d0eff0e0d0d0d0eh,0ffffffff0b0c0d0dh,0d0d0e0d0d0d0effh,0ffffffffff0b0c0dh,0d0d0d0d0d0effffh,0ffffffffffff0b0ch,0c0d0d0d0effffffh,0ffffffffffffff0bh,0d0d0d0d0d0effffh,0ffffffffffff0b0ch,0d0d0c0d0d0d0effh,0ffffffffff0b0c0dh,0d0c0b0c0d0d0d0eh,0effffff0b0c0d0dh,0cffff0b0c0d0d0dh,0d0eff0b0c0d0d0dh,0ffffffff0b0c0d0dh,0d0e0b0c0d0d0d0ch,0ffffffffff0b0c0dh,0cff0b0c0d0d0cffh,0ffffffffffff0b0ch,0ff0b0c0cffffh,2 dup(0h)
	sprite_madebykoren dq 0ffff00010010008eh,3 dup(0ffffffffffffffffh),0ffffffffffffff4eh,4d4effffffffffffh,9 dup(0ffffffffffffffffh),0ffff4d4effffffffh,2 dup(0ffffffffffffffffh),4e4dffffffffffffh,0ffff4e4dffffffffh,0ffffffffffffffffh,4e4f4effffffffffh,0ffffffffffffffffh,0ff4d504f4effffffh,0ffffffffffffffffh,4effffffffffffffh,0ffff4e4dffffff4dh,4 dup(0ffffffffffffffffh),4e4d4e4d4effffffh,0ffffffffffffffffh,0ffffff4d504f4effh,2 dup(0ffffffffffffffffh),0ff4e4f504dffffffh,0ffffff4e4f504dffh,0ffffffffffffffffh,0ff4c4d504dffffffh,0ffffffffffffffffh,0ffff4c4e4f504dffh,0ffffffffffffffffh,4d504f4effffffffh,0ffffff4e4f504dffh,4 dup(0ffffffffffffffffh),0ff4e4f504f504f4eh,4dffffffffffffffh,0ffffffff4c4e4f50h,2 dup(0ffffffffffffffffh),504d4c4d504f4effh,4e4d4eff4c4d504fh,4e4dffffffff4e4dh,4e4dff4c4e4f4e4dh,4effffffffff4e4dh,4eff4e4d4e4d504fh,0ffff4effffffff4dh
                       dq 504d4e4f504dffffh,4e4d4eff4c4c4e4fh,4e4d4effffffff4dh,0ff4d4e4d4effff4dh,4e4d4e4d4effffffh,504f4effffffffffh,4eff4c4d504d4e4dh,504f4effff4d4e4dh,4effffff4e4d4e4dh,4effffffff4d4e4dh,4f4effff4e4d4e4dh,4f4e4f4e4d504f50h,4f504f504f4e4c4eh,4f504f504dffff4eh,4f504f504d4c4d50h,4f504dffffffff4eh,4d504f4e4f504f50h,0ffffff4e4f4effffh,4c4e4f504d504f4eh,4d504f504f4eff4ch,4d504f504f4effffh,0ffff4d504f504f4eh,0ff4e4f504f504f4eh,4c4c4d504f4effffh,4f504f4e4c4c4d4ch,4f504f504dff4d50h,4f504f4eff4e4f50h,4f504f4effff4d50h,4e4f504dff4e4f50h,4c4d504d504d4e4fh,4e4f504d4e4d504dh,4e4f4e4d4e4f504dh,4e4f504d4e4f504dh,4e4d504f4effffffh,4e4c4e4f4e4d504fh,504dffff4c4d504fh,4eff4c4c4e4f504fh,4e4d504d4e4d504fh,504f4e4d4e4d504fh,504f4e4d504f4e4dh,0ffff4c4d504d4e4dh,0ffffff4c4c4d504dh,504d4e4d504f4e4ch,2 dup(504f4e4d504f4e4dh),504d4e4d504f4e4dh,4f504d504f4d4c4dh
                       dq 4dff4c4d4f4d4f50h,4f4d4d504f4d4d4dh,4f4d4d504d4c4c4dh,0ff4c4d504d4d4d4dh,4f4d4c4d4f504dffh,4f504d4d4f504d50h,4f504f4dffff4c4dh,4d504dffff4c4c4dh,4f504d504f4d4c4ch,4d4d4d504d4c4c4dh,4c4d4f504d4d4f4dh,4f4dffff4c4d4f4dh,4dffffffffff4c4dh,4d504f4d4c4c4d50h,4d4d4f4d4c4d4f50h,4d4d4f4d4d4d4d50h,4c4d4f4d4c4d4f50h,4d4f4f4d4d4f4f4dh,4f4f4f4d4d4f4f4dh,4c4d4f4d4d4f4f4fh,4f4f4f4d4d4f4dffh,4dffff4c4d4f4f4fh,4d4f4f4d4c4d4f4fh,4c4c4d4f4d4d4f4dh,4d4f4f4f4f4dffffh,0ff4c4d4f4dffffffh,4c4d4f4f4d4f4f4dh,4f4f4f4f4f4f4dffh,4f4d4c4d4f4f4d4dh,4c4d4f4dffff4c4dh,4d4f4dffffffffffh,4f4f4d4f4f4dff4ch,4f4f4d4d4f4d4c4dh,4f4f4d4d4f4f4f4fh,4f4d4c4d4f4d4c4dh,4f4d4d4f4f4d4d4fh,4f4d4d4d4f4d4d4fh,4dff4c4d4f4d4d4fh,4d4d4d4d4f4d4d4fh,4f4f4dffff4c4c4dh,4f4d4d4f4f4d4c4dh,0ffffff4c4d4f4f4fh,0ff4d4f4f4d4f4f4dh,4f4dff4c4d4f4dffh,4dff4c4d4f4f4d4fh,4d4c4d4d4d4d4d4fh
                       dq 4c4d4f4d4c4d4f4fh,0ffff4d4f4f4dffffh,0ff4c4d4f4dff4dffh,4c4d4f4f4d4f4f4dh,4d4d4d4f4d4d4f4dh,4c4d4f4f4d4c4d4dh,4d4f4f4d4c4d4f4dh,4d4f4f4d4c4d4d4ch,4d4f4f4d4d4d4f4dh,2 dup(4d4f4d4d4d4f4f4dh),4d4d4f4f4dffffffh,4f4f4f4d4c4d4f4fh,4f4dffffff4c4d4fh,4dff4d4f4f4d4d4fh,4d4d4f4f4d4d4f4fh,4f4f4dff4c4d4f4fh,4f4f4d4d4f4d4d4dh,0ffff4c4d4f4d4c4dh,4f4d4d4d4f4f4dffh,4f4f4d4d4f4f4d4dh,4f4d4c4d4f4f4d4dh,4f4d4d4d4f4f4d4dh,4f4d4c4d4f4f4d4dh,0ff4c4d4f4f4d4c4dh,4f4d4d4f4f4d4c4ch,4d4c4c4d4f4f4f4fh,4d4c4d4f4f4f4f4fh,0ff4c4d4f4f4f4f4fh,4d4f4f4f4f4dffffh,4c4d4f4f4dff4c4ch,4d4f4f4dffffff4ch,4f4dff4d4f4f4d4ch,4f4f4d4c4d4f4f4fh,4f4f4f4dffff4c4dh,4c4d4f4f4d4d4f4fh,0ffffffff4c4d4f4dh,4c4d4f4f4f4f4f4dh,4d4c4d4f4f4f4f4dh,4c4d4f4d4c4d4f4fh,4d4d4f4f4f4f4f4dh,4c4d4f4d4c4d4f4fh,0ffffff4c4c4d4dffh,4d4d4d4c4c4d4dffh,4d4dffff4c4c4d4dh,4d4dff4c4c4d4d4dh,0ffffff4c4c4d4d4dh
                       dq 0ff4c4c4d4d4d4dffh,0ffff4c4d4f4f4dffh,0ff4c4c4d4dffffffh,4d4d4dff4c4c4d4dh,4c4c4d4dff4c4c4dh,4d4d4d4d4dffffffh,4dff4c4c4d4d4c4ch,4dffffffffff4c4ch,4dff4c4c4d4d4d4dh,4d4dff4c4c4d4d4dh,4dff4c4c4dff4c4ch,4d4d4c4c4d4d4d4dh,0ffff4c4c4dff4c4ch,0ffffffffffff4c4ch,4c4c4c4cffff4c4ch,4c4c4cffffffff4ch,4c4c4cffffff4c4ch,0ffffffffffff4c4ch,4f4dffff4c4c4c4ch,0ffffffff4c4c4d4fh,4cffffff4c4cffffh,4c4c4c4cffffff4ch,0ffffff4c4cffffffh,0ff4c4c4c4c4cffffh,0ff4cffffff4c4cffh,4c4cffffffffffffh,4c4cffffff4c4c4ch,0ff4c4cffffff4c4ch,4c4cffffff4cffffh,0ff4c4cffff4c4c4ch,0ffffffffff4cffffh,5 dup(0ffffffffffffffffh),4c4d4f4f4dffffffh,0ffffffffffffff4ch,16 dup(0ffffffffffffffffh),0ffff4c4c4d4dffffh,17 dup(0ffffffffffffffffh),0ffffffffff4c4cffh,10 dup(0ffffffffffffffffh),0ffffffffffffh,2 dup(0h)


	; Masks
	mask_board dd 38080h,1807eh,1007e01h,17f7e01h,3 dup(0h)
	mask_boardstripes dq 1f800200108080h,5f8002003f8002h,1f61021f1f00021fh,5f00021f3f00021fh,1f21021e5f61021fh,3f21021e1f41021eh,3f61021e3f41021eh,5f41021e5f21021eh,407f0101h,2 dup(0h)
	mask_boardborder dq 5047d00148888h,6007d0405847d04h,18203038406047dh,8284030302020303h,385020283020303h,301030183830401h,103010284050301h,502010204830102h,8584010283010201h,285010186030102h,86840101h,2 dup(0h)
	
	mask_background_two dq 1205050e00191818h,60e04060206040bh,0b0b03060e080404h,10801060a0c0107h,0e0c010404110202h,1213040110060202h,0f0c010303050301h,606010212040301h,0c0a02010b110102h,60d010103110101h,0c110101090d0101h,0f0701010d090101h,11050101100c0101h,2 dup(0h)
	mask_background_four dq 30d140500141818h,90505040e040509h,0e12050304090404h,20a01070d020402h,809040106070302h,80a0301030a0103h,130c03010b040301h,5080101010d0102h,80b010108060101h,101501010c030101h,11030101h,2 dup(0h)
	mask_background_eight dq 206140300181818h,9090505020e1402h,10905040d100703h,310080212090405h,40406020e030503h,5120501020d0501h,160a01030f130301h,0c1001020c050201h,1410010213040102h,80d010103050101h,0d0401010a050101h,140501010e0d0101h,15100101h,2 dup(0h)
	mask_background_exponent dq 6090506000f1818h,0c0606040a0f0803h,0b0701050b0d0302h,80f02020d120501h,80803010c0a0401h,0f0502010e0e0201h,0a070101070f0101h,101301010c0b0101h,2 dup(0h)
	mask_background_plus dd 30c0ch,40c04h,4000404h,4080404h,3 dup(0h)
	mask_background_shmulik dq 70f0d0400351850h,7450d0407390d04h,0a3f0a040a210a04h,0a2d08040b1b0904h,0a3409030c270804h,110403070b160903h,0a03030407050306h,0d0602060c4a0602h,122f02050a250205h,0f09020405400402h,0a130203124b0204h,0a1c01050a4b0203h,60f01030d490401h,645010306390103h,0c070103080b0301h,63f020110030301h,804020106420201h,0b1f01020a160102h,0d0401020c4c0102h,110b0102104c0201h,903010113340102h,91f010109140101h,0b4e010109260101h,0d4c01010c150101h,113101010e0c0101h,114d010111330101h,122e0101120b0101h,2 dup(0h)
	mask_background_smiley dq 10080208000e1818h,70f040207080402h,0e1103020d050302h,0e0703010d130202h,0f0f01020c040102h,0f0801010d040101h,100601010f130101h,10100101h,2 dup(0h)

	dw offset mask_background_wtf
	mask_background_wtf dq 310090500171818h,708040503020409h,0a04040411100405h,0c11030311040404h,40104010b080302h,0b030401050b0202h,1011010310040103h,0b0a010211030301h,0e0401020c100201h,9070101040b0101h,120801010c0a0101h,1512010115050101h,2 dup(0h)
	
	mask_spawnanimation_tiny dq 0c0d080600032020h,0d1306010d0c0601h,2 dup(0h)
	mask_spawnanimation_medium dd 32020h,7081210h,8071001h,8181001h,3 dup(0h)
	mask_spawnanimation_full dd 32020h,1201eh,1001e01h,11f1e01h,3 dup(0h)
	mask_spawnanimation_half dq 1041e000c2020h,41c18041c01041eh,400010505001704h,11f030101000301h,1c1f03011c000301h,1b040101041b0101h,1b1b0101h,2 dup(0h)
	mask_spawnanimation_outline dq 1011e00082020h,11f1e0101001e01h,10101011f01011eh,1e010101011e0101h,1e1e0101h,2 dup(0h)

	mask_ui_score_outline dq 5270b040040123ch,61a0904060e0904h,1020804062f0904h,72207040d020408h,412040505370c02h,33304040d120405h,7060404041e0404h,0d1e040408330404h,10603050d330404h,42b0402090a0602h,4010502010601h,80d050106390501h,82e050108190501h,41c020204100202h,522020204310202h,0c0104010b080202h,0d39030109030103h,0f0f01030e220103h,0f3001030f1b0103h,4000201020b0201h,428010204090102h,52d020105170201h,0d000201083a0201h,0f2201020e170201h,422010110280102h,50f010104370101h,5300101051b0101h,624010106060101h,736010107330101h,0c020101080a0101h,101101010f0a0101h,10220101101d0101h,10320101h,2 dup(0h)
	mask_ui_score_main dq 5280b020033123ch,61b0902060f0902h,0e02020806300902h,932020707230702h,20206020e320207h,51d020605110206h,0e1d02060e110206h,909050201040205h,803010704330204h,80e050106370302h,82f0501081a0501h,52b020202090202h,906010307040103h,531010204010201h,6320102062a0201h,0d01010208390201h,30401010d370102h,51c010105100101h,604010105370101h,636010106230101h,71d010107110101h,0a08010107220101h,0d1101010d080101h,0d2201010d1d0101h,0e0101010d320101h,0e2301010e0a0101h,2 dup(0h)

		
	dw offset mask_number_0_outline
	mask_number_0 dq 4010f0300161712h,1403020c050e0e03h,6000b010104020ah,30c020407110901h,6010616050108h,100d040103020105h,404030113020104h,11040201050d0201h,2030101130e0102h,30b0101020e0101h,130c010104050101h,14020101h,2 dup(0h)
		
	dw offset mask_number_1_outline
	mask_number_1 dd 71709h,1051604h,2010204h,4000104h,60102h,1030102h,5000102h,3000101h,3 dup(0h)
		
	dw offset mask_number_2_outline
	mask_number_2 dq 1401030e001b1710h,30c07030102020bh,0e0604020a0a0204h,1004030200040107h,0c0805010b090501h,1202020203010104h,0c0a010303090103h,80b0201040b0201h,140002010d0a0102h,2010101140f0201h,4020101020d0101h,0e0a01010d070101h,110301010f050101h,1304010113010101h,2 dup(0h)
		
	dw offset mask_number_3_outline
	mask_number_3 dq 1402030a00161710h,30308010b0e02h,0d0d08020a040307h,0f0c0701030d0602h,0f0f040101010302h,309010212010401h,1300020109090102h,20d0101130a0102h,401010103030101h,0c0d0101090d0101h,130201010d0a0101h,150d0101h,2 dup(0h)
		
	dw offset mask_number_4_outline
	mask_number_4 dq 10c160300121713h,0f0f03040f01030bh,308040207050204h,10a03020b020204h,0d01020309040203h,0e000301000b0103h,5070201040a0201h,606010102090101h,0a03010109070101h,0d040101h,2 dup(0h)
		
	dw offset mask_number_5_outline
	mask_number_5 dq 5040900121710h,0b0c0a030901030bh,10207031402030ah,0d0f060103010601h,0e030112010401h,0a0c010208020102h,0c0a01020c020102h,13000201120b0201h,150c010213020102h,40101h,2 dup(0h)
		
	dw offset mask_number_6_outline
	mask_number_6 dq 5010f0300191711h,140403090b0d0903h,104020b09050308h,302020407000b01h,0e10040100070106h,30c0103140d0202h,30601020a040301h,0a0d010205040201h,120402010c0b0102h,14020102120c0201h,0c05010102030101h,130501010d0c0101h,15030101130b0101h,2 dup(0h)
		
	dw offset mask_number_7_outline
	mask_number_7 dq 1040d00131710h,0d06050312040503h,9080403050a0304h,8090104010e0401h,40b010301000301h,0d090301090b0301h,0b07020114030301h,1207020110050201h,7090101020f0101h,0d0a0101090c0101h,2 dup(0h)
		
	dw offset mask_number_8_outline
	mask_number_8 dq 1403030b00211711h,0e0d06040e000604h,0a0603070103020bh,30d060303010603h,5010709030503h,0d0b0105090a0105h,30b010203040102h,0c02020105100201h,140101020c0d0102h,2020101140e0102h,4040101020e0101h,8040101040c0101h,9020101080c0101h,0a0d010109060101h,0e0401010d010101h,130c010113040101h,150e010115020101h,2 dup(0h)
		
	dw offset mask_number_9_outline
	mask_number_9 dq 50d0d03001b1711h,1402030903010a03h,0c0402080103020ah,120b0204030b0204h,5010604000701h,0e05010509100501h,0a0c0301140b0202h,304010213010301h,0a040201050c0201h,0d0201020b0a0102h,2020101100c0201h,30a0101020d0101h,0b05010104040101h,140d0101130a0101h,2 dup(0h)

	mask_number_0_outline dq 5010f0500181914h,1404040c060e0e05h,7000b010105040ah,1806010808130901h,30f030200070106h,1402020203030202h,50c010305060301h,14100301110d0301h,60d020104110201h,204010112060201h,4020101020f0101h,1411010105070101h,16030101h,2 dup(0h)
	mask_number_1_outline dq 20516060008190bh,104010603010404h,202010318060104h,7010204000301h,7010102h,2 dup(0h)
	mask_number_2_outline dq 1402050e00201912h,50c06050103040bh,0d08030510050404h,501070b0a0206h,30e020202020401h,1401040112030202h,503010314100401h,301020110090103h,90b0201050a0102h,0e0702010d0d0102h,1500020111090102h,20e010115110201h,603010104100101h,0c090101060b0101h,0f0601010e0d0101h,1209010111040101h,13020101h,2 dup(0h)
	mask_number_3_outline dq 20c1603001c1912h,4050814030509h,0e0f08020a050507h,40f060202010403h,50b050113010402h,0b04030110110401h,10c010201020102h,30f010114000201h,50a010105040101h,90a010106020101h,0d0f01010a0f0101h,120201010f0b0101h,130b010113030101h,17020101160f0101h,180c0101h,2 dup(0h)
	mask_number_4_outline dq 20c160500171915h,40804040f02050ah,80503050b030404h,0c02030f110503h,20a02020f000302h,0c0203010b070301h,180d010310140301h,80a020106070201h,10f0101010b0101h,706010103090101h,0b0801010a040101h,120101010e010101h,2 dup(0h)
	mask_number_5_outline dq 2020c0500191912h,706081402040dh,90705050c0c0805h,40109011803010ah,0a0c0203010f0302h,502020e110601h,1400020213010104h,1030102140f0202h,0f01010e030102h,90c0101040f0101h,0e0b01010b0f0101h,130b010112020101h,160f010116010101h,2 dup(0h)
	mask_number_6_outline dq 6010f05001c1913h,105040b0b0d0c04h,907050614060507h,0c11090108000b01h,8010605020107h,1503020309060601h,0f12040103030202h,50d010302100301h,170d01030a0d0103h,1704010206060201h,402010102040101h,0e0c0101090d0101h,130c010113060101h,1805010115020101h,180d0101h,2 dup(0h)
	mask_number_7_outline dq 2060d00151912h,0c07050511050803h,10f0801060a0604h,200030211080701h,60e050113040601h,809040102100401h,0c0c030111090202h,150303010e060301h,130902010a080201h,311010101010101h,0c0d010105010101h,2 dup(0h)
	mask_number_8_outline dq 203160300201913h,60507020d1603h,140605070a060507h,0f1006030f000603h,410060204010602h,10d010201040102h,906010206120201h,0d020201090b0102h,150101020d100201h,1804010215100102h,3020101180d0102h,506010103100101h,0a020101050c0101h,0e0101010a100101h,0f0601010e110101h,160201010f0c0101h,16100101h,2 dup(0h)
	mask_number_9_outline dq 40d1104001e1913h,1403050904010a05h,0c06040700060506h,10c070106110d01h,110c070105000701h,0e03020301040302h,0a12050114010302h,20d020210060105h,2030201150d0103h,160d01020b0b0102h,3020101010d0101h,5060101030f0101h,0b060101050b0101h,130201010e020101h,17020101130b0101h,170d0101h,2 dup(0h)

	mask_button_shadow dd 21717h,2151402h,16020114h,3 dup(0h)
	mask_button_border dq 10214000c1717h,214120214010214h,200010303001102h,115010101000101h,1302010102130101h,1400010113130101h,14150101h,2 dup(0h)
	mask_button_body dd 11717h,2021212h,3 dup(0h)

	mask_icon_restart dq 704080300131717h,5060207070d0404h,40801040f060207h,707010205100201h,0d070201090c0201h,60501010e0d0102h,60f0101060d0101h,8070101070c0101h,0e0801010a0b0101h,0f0d01010f050101h,2 dup(0h)
	mask_icon_mainmenu dd 21717h,506030ah,0d06030ah,3 dup(0h)
	mask_icon_shake dq 60b050200161717h,40703020b050205h,8020105080d0203h,0c0e01040d080501h,0e0c04010d0d0401h,7050103030c0301h,2080201090a0301h,0a08010208100102h,0d0902010c030102h,0f1102010d0e0102h,606010110100201h,0e0e0101h,2 dup(0h)
	mask_icon_animation dq 4070207000f1717h,50604010a100403h,80f0202060e0202h,0f0502020b030202h,812020107050201h,0e1101020b0e0102h,6070101050e0101h,0c0f0101060d0101h,2 dup(0h)

	mask_icon_bigrestart dq 3b45010100998080h,5814010127440105h,6824020270360115h,58150301174e0102h,6b32051e27490305h,1b1e01026c530104h,29140201334c0101h,311122053c0f0f02h,6b50040355500202h,54520308132d0318h,5b44010550290401h,1e60020235100701h,531202011d610101h,552d01012a4b0103h,1f5c01016b2c0306h,344b0b065f190101h,2929010a304f0101h,564e01023a460505h,3d4302012f500201h,5a47010221190101h,1e1b0101645d0105h,1a540102302a0101h,6c2a01021f1a0603h,146a040439470101h,645b060237490302h,4c2702012e120301h,2828010d631c0101h,1232010d2a290901h,271504016d530102h,682301015b350102h,324d0201572f0201h,6b280104574d0511h,2b13060365210305h,53130503584b0102h,4e260603675d0102h
                         dq 5c5b0808562d0302h,1866080858300101h,1921010127261301h,1b6301012d4f0102h,1c58020116680202h,17240102651f0102h,24170101595e0302h,1d59010127270111h,5b610101555a0201h,5d6305015d1a0503h,142a020328270f01h,565b0101364a0101h,18510101126c0202h,251638102e2a0103h,195102031a200202h,594903045a330202h,665d01031b510507h,29280c01655d0104h,6b53010628470102h,5d1d0809522a0201h,2a2a010715490102h,1e580204621b0102h,1a64020238480201h,5354010466200101h,182204042b2a0106h,1c1d09095d180202h,3c44030215690101h,592d030622180302h,532b010154260807h,136b010149260501h,19650101184e1503h,685d01012f2a0102h,5d17010120511f1dh,314e03036e2f0103h,144502042c2a0105h
                         dq 3e42010117670101h,5a60020115280102h,1c620404585e0101h,4b100501116d0101h,5c260f352d2a0104h,1d1c02011f5f0101h,2b4d010116261128h,2 dup(0h)
	mask_icon_bigstart_shadow dq 7134010400438080h,713802156e530204h,284401032e500101h,6f2e010433290601h,2c2f01042a310106h,5e640101522b0101h,2b4b01026c570302h,68220101661f0101h,6d550102322c0101h,6b2601026a5b0102h,70310105136f0101h,4e29020169230101h,502a0201714d0105h,5f640502651e0101h,6c28010228350103h,2d2e01044b280301h,293301073f450229h,685e0101312c0102h,6a5f01013a260f02h,6f50010362630201h,302c010367620101h,704b010a695d0302h,40440101302b0501h,6d590102675f0302h,146e2d0266620102h,6660010149270301h,656104012f2c0104h,6d2a01022738020ch,312a06016a250101h,2c4d01012e2d0104h,6462020329460103h,3528070137270301h,6e2c01032b300105h,6b5902042a490102h,2 dup(0h)

	mask_clickanywhere dq 0a570101009912c9h,0c47040104bc0302h,756050104600204h,0c7b01010c0a0101h,4020201044a0302h,1c70902018a0b02h,0cb70101092f0402h,56409020b6a0101h,0d0e0209b20402h,5170101043a0101h,5e01010b980101h,0abe02010e460101h,0c31010100ae0e02h,66a01010d300105h,0c990101044e0402h,1202020c820101h,46a020507c30301h,49402050b090102h,0c25010105a30c02h,722030209020401h,5b8090202090202h,4a502040c170101h,52f010106530601h,56f0101087d0204h,59901010ebf0101h,67c010106180101h,15e0d020f450202h,946040106490701h,569010105540302h,4c3030206c20701h,0b940101066f0302h,5a903010cb40101h,0cc7020207440302h,4a4010105000602h,625010109480501h,1145010105350902h
                       dq 0c26020211be0101h,474010101040205h,47c020508b40204h,0c7c020605930101h,4180206057b0101h,4120a0205390902h,0c5002030c180206h,45a030209bf0401h,692060205240301h,0c0302070b570303h,855010106990602h,681030207ab0401h,0b7c010106230101h,0fbe0202097c0101h,7590402074a0301h,573090206160602h,200e0204b80101h,43f0101096a0101h,58101010b010101h,7bd030205aa0801h,0b03010110440201h,0ba5010106980101h,464010103010201h,86b020411a40101h,0c93010105b20101h,668060210bd0201h,0b240102043b0204h,0aa9020104750203h,53f090202020202h,0db30105048c0203h,0c7001010a450201h,0a23010204300205h,0cc00401067a0602h,0c34010108310204h,0c69010106940101h,0b18010104350101h
                       dq 0c8b020409520301h,0c94020504b30205h,425020209c10501h,4430302084f0402h,0ca502050c6a0206h,2 dup(0h)

	mask_logo_2 dq 210f010100483725h,107061407070107h,1b1d0103021b0102h,0a1901021f170105h,2c0c01032f010101h,61b140709070101h,1917010125120104h,2010020107140104h,261201032b050201h,205020230020722h,2117010328120101h,300004021d130201h,2907010108070103h,2b0c01041c140302h,2a0c010509220d02h,1d1d010120170104h,250b050728080201h,240c01011f110606h,2c04010108170101h,1622020103040101h,0b1a01011a1d0104h,4030604230d0201h,1e120101220e0303h,2e0c010107220201h,1a1605072d0c0102h,22170102000b010dh,3401020105200101h,2d0303030a040102h,31b03041b150101h,141a020123170101h,1c1d01020d240601h,3024060116190402h,1818020107180303h,2a06060605020401h,41f020127090302h
                dq 260a01012e020201h,27120102h,2 dup(0h)
	mask_logo_0 dq 0e020301004b382ch,92604022b1f0607h,30a01022d1e0201h,71b020433090102h,2a0c030130180103h,71f060707060508h,2b2602032c0d0101h,2d060409010e0102h,80e01030c032107h,310701012f100101h,321010104090303h,70e010606250101h,90e0102102a0401h,2702030104210303h,280a05022d050301h,826010131080203h,142a100211011602h,0d231e0705080201h,300f010507180103h,805040121220a01h,0a1e010106070101h,0d210502091d0102h,312104010c0b0202h,3610020c26210501h,242a0401340a0101h,2f2601010b280201h,0d2002012e1d0101h,360d0103020c0515h,250a030131220302h,52402012d260202h,2d0401010a0e0101h,0e0b020112220501h,2e0f0201361c0103h,2920020132240101h,180008012f1b0204h
                dq 310b05160a040201h,11c010331240102h,0c0a07010010020ch,2 dup(0h)
	mask_logo_4 dq 8130302002f382dh,0b1104071c0c0301h,1b010419060303h,5150606371e0104h,150907061f020101h,130b02010f150301h,110c0402140a0101h,119020921000801h,1512010102180101h,170802010f0e0606h,151004010b190101h,361c01081c0a0601h,0c10010104160101h,150f06010f140401h,2301071a1d030301h,1c0d010120010303h,1c0b04011b050101h,1511030102220101h,232c06010d0f0202h,31b330909120201h,23240708100d0101h,31702041c040706h,71401010f160101h,0b18030118070101h,2 dup(0h)
	mask_logo_8 dq 121e0101005d3829h,171f0302160e0102h,30180103221e0101h,151b01011d220102h,2002010121010202h,221f040123090101h,10a061504050103h,2d0a010123000b03h,71c030303070101h,141c02011b080101h,370d010f2d1e0201h,1711070e30020101h,150a0204000d010eh,52202021e040101h,208030215030101h,2c270301120a0301h,1e17010333050101h,332301010b010801h,70a0106021f0102h,1619010c07030101h,0a1d0102090b0101h,310a061517230101h,3120050131230103h,131d030209260b01h,718010417210202h,1706020320201107h,1f09010522270301h,2f0c01012e010202h,201b01021c060303h,170501011e1a020bh,71f0f072c090a01h,31f04031f031406h,2e0a030206240101h,2b1f0b01081b0101h,2e1d01010b1e0101h
                dq 2527070205041206h,90a03011d050201h,300c01041f250101h,3121040235080101h,422010121090103h,3223010208020d02h,140b01010c270501h,201d0203080a0104h,1c1f020333060203h,170908082f1b0204h,2209010220090104h,190701021b1f0101h,2 dup(0h)

	
	;   ____                        _                _      
	;  / ___| __ _ _ __ ___   ___  | |    ___   __ _(_) ___ 
	; | |  _ / _` | '_ ` _ \ / _ \ | |   / _ \ / _` | |/ __|
	; | |_| | (_| | | | | | |  __/ | |__| (_) | (_| | | (__ 
	;  \____|\__,_|_| |_| |_|\___| |_____\___/ \__, |_|\___|
	;                                          |___/        
	
	listID_board dw nullword
	listID_boardAvailable dw nullword
	listID_boardMerged dw nullword
	listID_boardAnimation dw nullword

	listOffset_board dw nullword
	listOffset_boardMerged dw nullword
	listOffset_boardAnimation dw nullword

	game_boardOffset dw nullword
	game_rendercycles dw 0
	game_mode dw gamemodePlaying
	game_loseTimer dw nullword
	game_score dw 0


	

CODESEG



proc MainDelay
	; parameters:
	; - wait time (roughly in seconds)
	; returns nothing.
	push bp
	mov bp, sp
	push ax bx cx
	waitTime equ [word ptr bp + 4]
	mov cx, waitTime
	xor ax, ax
	Delay_Loop:
		inc ax
		cmp ax, 0ffffh
		jb skipdont
			mov ax, 0
			loop Delay_Loop
		skipdont:
		inc cx
	loop Delay_Loop
	pop cx bx ax bp
	ret 2
endp MainDelay



proc NumberClamp
	; Info: Takes a number and clamps it to a minimum & maximum.
	; Parameters: Input Number, Minimum Number, Maximum Number
	; Returns: Clamped Number
	push bp
	mov bp, sp
	push ax

	inputNumber equ [word ptr bp + 8]
	minimumNumber equ [word ptr bp + 6]
	maximumNumber equ [word ptr bp + 4]

    mov ax, inputNumber
    cmp ax, maximumNumber
    jb NumberClamp_DontClamp1
        mov ax, maximumNumber
    NumberClamp_DontClamp1:
    cmp ax, minimumNumber
    ja NumberClamp_DontClamp2
        mov ax, minimumNumber
    NumberClamp_DontClamp2:
    mov inputNumber, ax

	pop ax
	pop bp
	ret 4
endp NumberClamp

proc NumberMin
	; Info: Returns the lower value between 2 values.
	; Parameters: Value1, Value2
	; Returns: Lower Value
	push bp
	mov bp, sp
	push ax
	value1 equ [word ptr bp + 6]
	value2 equ [word ptr bp + 4]
    mov ax, value2
	cmp ax, value1
	jl NumberMin_Skip
    	mov value1, ax
	NumberMin_Skip:
	pop ax
	pop bp
	ret 2
endp NumberMin

proc NumberMax
	; Info: Returns the higher value between 2 values.
	; Parameters: Value1, Value2
	; Returns: higher Value
	push bp
	mov bp, sp
	push ax
	value1 equ [word ptr bp + 6]
	value2 equ [word ptr bp + 4]
    mov ax, value2
	cmp ax, value1
	jg NumberMax_Skip
    	mov value1, ax
	NumberMax_Skip:
	pop ax
	pop bp
	ret 2
endp NumberMax

proc NumberMod 
	; Info: Returns the modulo of a number.
	; Parameters: Input Number, Divisor
	; Returns: Modulo
	push bp
	mov bp, sp
	push ax dx

	inputNumber equ [word ptr bp + 6]
	divisor equ [word ptr bp + 4]

    mov ax, inputNumber
    mov dx, 0
    idiv divisor
    mov inputNumber, dx

	pop dx ax
	pop bp
	ret 2
endp NumberMod

proc NumberRandom
	; Info: Returns a random number between a minimum and a maximum, Not including max.
    ; Formula: ((clock * internal_primes[internal_primeCounter])%(max-min))+min
	; Parameters: Minimum, Maximum
	; Returns: Random Number
	push bp
	mov bp, sp
	push ax bx cx dx es

	min equ [word ptr bp + 6]
	max equ [word ptr bp + 4]

	mov ax, 40h
	mov es, ax
	mov ax, [word ptr es:6Ch]
	mov bx, offset internal_primes
	add bx, [word ptr internal_primeCounter]
	mul [word ptr bx]
	add ax, dx
	mov dx, 0
	mov bx, max
	sub bx, min
	div bx
	add min, dx
	
	inc [word ptr internal_primeCounter]
	cmp [word ptr internal_primeCounter], 200
	jb NumberRandom_DontResetinternal_primeCounter
		mov [word ptr internal_primeCounter], 0
	NumberRandom_DontResetinternal_primeCounter:

	pop es dx cx bx ax
	pop bp
	ret 2
endp NumberRandom

proc NumberCubicCurve
	; Info: Returns a cubic out curve, using some fancy shmancy math
	; Parameters: N Start, N End, Frame
	; Returns: Final Coordinate
    push bp
    mov bp, sp
    push ax bx cx dx di si
    nStart equ [word ptr bp + 8]
    nEnd equ [word ptr bp + 6]
    frame equ [word ptr bp + 4]

	xor dx, dx
	mov ax, constant_animationTotalFrames
	imul ax
	mov cx, ax ; CX = G^2
	mov bx, nEnd
	sub bx, nStart
	shl bx, 5 ; BX = S(Ne-Ns)
	xor dx, dx
	mov ax, constant_animationTotalFrames
	sub ax, frame ; AX = (G-F)
	mov si, ax ; SI = (G-F)
	imul si ; AX = (G-F)^2
	imul bx ; DX:AX = S(Ne-Ns)((G-F)^2)
	idiv cx ; AX = S(Ne-Ns)((G-F)^2) / G^2
	imul si ; AX = (G-F)^3
	mov cx, constant_animationTotalFrames
	idiv cx ; AX = S(Ne-Ns)((G-F)^3) / G^3
	mov cx, nEnd
	shl cx, 5
	sub cx, ax ; CX = SNe - (S(Ne-Ns)((G-F)^3) / G^3)
	mov nStart, cx ; Return CX
    
    pop si di dx cx bx ax
    pop bp
	ret 4
endp NumberCubicCurve

proc NumberCubicCurveCache
	; Info: Returns a cubic out curve, using a cache of fancy shmancy math.
	; Parameters: N Start, N End, Frame
	; Returns: Final Coordinate
    push bp
    mov bp, sp
    push ax bx cx dx di si
    nStart equ [word ptr bp + 8]
    nEnd equ [word ptr bp + 6]
    frame equ [word ptr bp + 4]

	mov di, nStart
	cmp nEnd, di
	jb NumberCubicCurveCache_DontFix
		dec nEnd
	NumberCubicCurveCache_DontFix:
	shl di, 1
	add di, nStart ; AX = nStart * 3
	add di, nEnd ; AX = (3*nStart)+newNEnd
	mov bx, di

	shl di, 6
	add di, frame
	add di, offset internal_curveCache
	xor ah, ah
	mov al, [byte ptr di]
	mov nStart, ax
    
    pop si di dx cx bx ax
    pop bp
	ret 4
endp NumberCubicCurveCache

proc NumberGetStringLength
	; Info: Takes a string offset, and returns the length of the string in pixels.
	; Parameters: String Offset
	; Returns: String Length
    push bp
    mov bp, sp
    push ax bx cx dx di si
    stringOffset equ [word ptr bp + 4]
	
	mov di, stringOffset
	xor ax, ax
	xor bh, bh
	xor ch, ch
	NumberGetStringLength_ReadLoop:
		mov bl, [byte ptr di]
		cmp bl, 0
		je NumberGetStringLength_ExitReadLoop
		shl bl, 1
		mov si, [word ptr internal_fontOffsets+bx]
		mov cl, [byte ptr si]
		add ax, cx
		add ax, constant_characterSpacing
		inc di
	jmp NumberGetStringLength_ReadLoop
	NumberGetStringLength_ExitReadLoop:
	mov stringOffset, ax
    
    pop si di dx cx bx ax
    pop bp
	ret
endp NumberGetStringLength

proc NumberToString
	; Info: Takes an unsigned integer and parses it into a base-10 string at the specified offset.
	; Parameters: Input Number, String Offset
    push bp
    mov bp, sp
    push ax bx cx dx di si
    inputNumber equ [word ptr bp + 6]
    stringOffset equ [word ptr bp + 4]
	mov di, stringOffset
	mov ax, inputNumber
	mov bx, 10
	mov cx, 0

	NumberToString_DigitLoop:
		cmp [byte ptr di], 1 ; This is the absolute end
		je NumberToString_FinishDigitLoop
		xor dx, dx
		div bx ; AX = DX:AX/10, DX = Mod(DX:AX,10)
		;xor ax, ax
		;xor dx, dx
		add dx, 30h
		mov [byte ptr di], dl
		inc di
		inc cx
		cmp ax, 0
		je NumberToString_FinishDigitLoop ; if AX/10
		jmp NumberToString_DigitLoop
	NumberToString_FinishDigitLoop:
	mov [byte ptr di], 0
	
	mov si, di
	sub si, cx ; SI = StringArrayOffset + Index of Last Digit + NumOfDigits + 1
	shr cx, 1 ; CX = Floor(NumOfDigits/2)
	cmp cx, 0
	je NumberToString_DontReverseString
	NumberToString_ReverseLoop:
		dec di
		mov al, [byte ptr si]
		mov ah, [byte ptr di]
		mov [byte ptr di], al
		mov [byte ptr si], ah
		inc si
		loop NumberToString_ReverseLoop
	NumberToString_DontReverseString:

    
    pop si di dx cx bx ax
    pop bp
	ret 4
endp NumberToString





proc ListCreate
	; Info: Creates a list to the allocation
	; Parameters: Element Length (Bytes), List Length (Elements)
	; Returns: List ID
	push bp
	mov bp, sp
	push ax bx cx dx di si

	elementLength equ [word ptr bp + 6]
	elementAllocationLength equ [word ptr bp + 4]

	; Get list memory length
	mov ax, elementLength
	mov dx, 0
	mul elementAllocationLength
	mov si, [word ptr lists_offset]
	add [word ptr lists_offset], ax ;we do this little double thing so that lists_offsets gets permanently added to.


	; Get lists amount
	mov bx, [word ptr lists_amount]
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset
	mov [word ptr bx], si ;move the allocation offset first things first
	mov cx, elementLength
	mov [word ptr bx + 2], cx ;move the element length
	mov cx, elementAllocationLength
	mov [word ptr bx + 4], cx ;move the element allocation length
	mov [word ptr bx + 6], 0 ;move the count, which is a 0

	; We do this little trickery to return the ID of the newly created list.
	mov ax, [word ptr lists_amount]
	mov elementLength, ax
	inc [word ptr lists_amount]

	pop si di dx cx bx ax
	pop bp
	ret 2
endp ListCreate

proc ListCount
	; Info: Returns the count of a list.
	; Parameters: List ID
	; Returns: List Count
	push bp
	mov bp, sp
	push ax bx

	listID equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	; Move the count to it
	mov ax, [word ptr bx + 6]
	mov listID, ax

	pop bx ax
	pop bp
	ret
endp ListCount

proc ListSet
	; Info: Sets an element in a list with an index and a reference.
	; Parameters: List ID, Element Reference, Index
	push bp
	mov bp, sp
	push ax bx cx dx di si

	listID equ [word ptr bp + 8]
	elementReference equ [word ptr bp + 6]
	index equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	; Move the offset of the list
	mov di, [word ptr bx]
	; Get the element length
	mov ax, [word ptr bx+2]
	mov cx, ax ;Save it in cx before multiplying

	mul index ;Multiply it by the index
	add di, ax ;DI = ListOffset + (ElementLength * Index)
	mov si, elementReference ;SI = ElementReferenceOffset

	ListSet_Loop: ;Setting byte by byte, because i'm an idiot and terribly scared of movsb
		mov dl, [byte ptr si]
		mov [byte ptr di], dl
		inc di
		inc si
	loop ListSet_Loop


	pop si di dx cx bx ax
	pop bp
	ret 6
endp ListSet

proc ListClear
	; Info: Clears a list.
	; Parameters: List ID
	push bp
	mov bp, sp
	push ax
	xor ah, ah
	mov al, nullbyte
	push [word ptr bp + 4]
	push ax
	call ListSetAll

	pop ax bp
	ret 2
endp ListClear

proc ListSetAll
	; Info: Sets all the list values to a given byte.
	; Parameters: List ID, Byte to set (lower half)
	push bp
	mov bp, sp
	push ax bx cx dx di si es

	mov ax, ds
	mov es, ax

	listID equ [word ptr bp + 6]
	setByte equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	mov [word ptr bx+6], 0 ; Set the count of the list to 0
	; Move the offset of the list
	mov di, [word ptr bx]
	; Get the element length
	mov ax, [word ptr bx+2]
	mov dx, 0
	mov si, [word ptr bx+4] ;Save the element *length*, this'll serve as the index
	mul si ;Multiply it by the index
	mov cx, ax ; CX = ElementLength * Count
	mov ax, setByte
	cmp cx, 0
	jz ListSetAll_NoLoop
	rep stosb ;mov es:[di], al
	ListSetAll_NoLoop:

	pop es si di dx cx bx ax
	pop bp
	ret 4
endp ListSetAll

proc ListAdd
	; Info: Adds something to the list, wrapped around ListSet
	; Parameters: List ID, Element Reference
	push bp
	mov bp, sp
	push bx cx

	listID equ [word ptr bp + 6]
	elementReference equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	; Get the list count, this'll serve as an index.
	mov cx, [word ptr bx+6]
	inc [word ptr bx+6] ;Increase the index
	push listID
	push elementReference
	push cx ;Index
	call ListSet

	pop cx bx
	pop bp
	ret 4
endp ListAdd

proc ListGetAdd
	; Info: Gets the offset of the first null element in a list, and increases the list's count.
	; Parameters: List ID
	; Returns: Element Offset
	push bp
	mov bp, sp
	push bx cx

	listID equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	; Get the list count, this'll serve as an index.
	mov cx, [word ptr bx+6]
	inc [word ptr bx+6] ;Increase the count
	cmp cx, [word ptr bx+4] 
	jb ListGetAdd_NotOverflowing
		;if index >= listlength
		; If it is overflowing, we will turn back the count one dial.
		dec [word ptr bx+6] ;Decrease the count
		dec cx ;Decrease the index
	ListGetAdd_NotOverflowing:
	push listID
	push cx ;Index
	call ListGet
	pop listID

	pop cx bx
	pop bp
	ret
endp ListGetAdd

proc ListRetrieve
	; Info: Returns an element from a list via an index and memory reference.
	; Parameters: List ID, Element Reference, Index
	push bp
	mov bp, sp
	push ax bx cx dx di si

	listID equ [word ptr bp + 8]
	elementReference equ [word ptr bp + 6]
	index equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	; Move the offset of the list
	mov di, [word ptr bx]
	; Get the element length
	mov ax, [word ptr bx+2]
	mov cx, ax ;Save it in cx before multiplying

	mul index ;Multiply it by the index
	add di, ax ;DI = ListOffset + (ElementLength * Index) = ListElementReferenceOffset
	mov si, elementReference ;SI = ElementReferenceOffset

	ListRetrieve_Loop: ;Setting byte by byte, because i'm an idiot and terribly scared of movsb
		mov dl, [byte ptr di]
		mov [byte ptr si], dl
		inc di
		inc si
	loop ListRetrieve_Loop


	pop si di dx cx bx ax
	pop bp
	ret 6
endp ListRetrieve

proc ListGet
	; Info: Returns the offset of a list's element via an index.
	; Parameters: List ID, Index
	; Returns: Element Offset
	push bp
	mov bp, sp
	push ax bx dx di

	listID equ [word ptr bp + 6]
	index equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset
	
	; Move the offset of the list
	mov di, [word ptr bx]
	cmp index, 0
	je ListGet_JustListOffset
	; Get the element length
	mov ax, [word ptr bx+2]
	mul index ;Multiply it by the index
	add di, ax ;DI = ListOffset + (ElementLength * Index) = ListElementReferenceOffset

	ListGet_JustListOffset:
	mov listID, di

	pop di dx bx ax
	pop bp
	ret 2
endp ListGet

proc ListForeach
	; Info: Runs through every element in a list, with a callback function
	; The callback offset should be a label, make sure to ret at the end of it and push used registers.
	; DI register is set to the offset of the list element.
	; CX register is set to the loop iterations left.
	; AX register is set to the list's element length.
	; ---
	; Parameters: List ID, Callback Offset, ?Run Through Nulls
	push bp
	mov bp, sp
	push ax bx cx dx di si

	listID equ [word ptr bp + 8]
	callbackOffset equ [word ptr bp + 6]
	runThroughLength equ [word ptr bp + 4]

	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	; Move the offset of the list
	mov di, [word ptr bx]
	; Get the element length
	mov ax, [word ptr bx+2]
	; Get the list count
	mov cx, [word ptr bx+6]
	cmp runThroughLength, boolTrue
	jnz ListForeach_LengthCheck
		; Get the list length instead
		mov cx, [word ptr bx+4]
	ListForeach_LengthCheck:
		cmp cx, 0
		jz ListForeach_Empty
	ListForeach_Loop:
		call callbackOffset
		add di, ax
		loop ListForeach_Loop
	ListForeach_Empty:
	pop si di dx cx bx ax
	pop bp
	ret 6
endp ListForeach

proc ListRemove
	; Info: Removes an element from a list via index, and collapses it.
	; Parameters: List ID, Index
	push bp
	mov bp, sp
	push ax bx cx dx di si

	listID equ [word ptr bp + 6]
	index equ [word ptr bp + 4]
	
	; Get list info offset
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	mov cx, [word ptr bx+6]

	cmp index, cx ;Make sure index is within list bounds, this also makes sure list count has to be >0
	jae ListRemove_Fail

	; Move the offset of the list
	mov di, [word ptr bx]
	; Get the element length
	mov ax, [word ptr bx+2]

	; Decrease the element count, then get it
	dec [word ptr bx+6]
	dec cx

	mov bx, ax ;Save element length in bx

	mul index ;Multiply it by the index
	add di, ax ;DI = ListOffset + (ElementLength * Index) = ListElementReferenceOffset
	mov si, di
	add si, bx ;SI = ListGet(Index+1)

	sub cx, index ;cx = element count - index - 1
	ListRemove_Loop:
		push cx ;nested loop
		mov cx, bx ; cx = element length
		ListRemove_LoopCopyByte:
			mov al, [byte ptr si]
			mov [byte ptr di], al ;Copy the index+1 element to index
			inc di
			inc si
			loop ListRemove_LoopCopyByte
		pop cx
		loop ListRemove_Loop
		
	mov cx, bx
	ListRemove_LoopDeleteByte:
		mov [byte ptr di], nullbyte ;Copy the index+1 element to index
		inc di
		loop ListRemove_LoopDeleteByte

	ListRemove_Fail:
	pop si di dx cx bx ax
	pop bp
	ret 4
endp ListRemove

proc ListSetCount
	; Info: Sets the list's count, doesn't clear null elements. if 'Count' is null, will set list's count to max.
	; Parameters: List ID, Count

    push bp
    mov bp, sp
    push ax bx cx dx di si
    listID equ [word ptr bp + 6]
    count equ [word ptr bp + 4]
	
	mov bx, listID
	shl bx, 3 ;every list info is 8 bytes exactly
	add bx, offset lists_info ;this is now the list's info offset

	mov cx, count ;cx is the intended count.
	cmp cx, nullword ;if cx is null, set it to list length
	jne ListSetCount_NormalLength
		mov cx, [word ptr bx+4] ;set the count to the list's length, aka its max
	ListSetCount_NormalLength:

	push cx
	push 0
	push count
	call NumberClamp ;clamp count to normal numbers.
	pop [word ptr bx+6] ;finally, set the list's count to cx.

    
    pop si di dx cx bx ax
    pop bp
	ret 4
endp ListSetCount




proc RenderScreen
	; Info: Renders the game's objects onto the screen.
	push ax bx cx dx si
	call BufferClear
	
	call RenderPreLoop
	call RenderShake
	call RenderParticles
	cmp [word ptr game_mode], gamemodeMainMenu
	je RenderScreen_SkipGameRender
		call RenderBoard
		call RenderBlocks
		call RenderAnimation
		call RenderGameUI
	RenderScreen_SkipGameRender:
	
	call RenderCursor

	inc [word ptr game_rendercycles]
	pop si dx cx bx ax
	ret
endp RenderScreen

proc RenderPreLoop
	; Info: Called before every render.
	push ax
	; If no-animation toggle is turned on, turn the animation frame null.
	cmp [word ptr internal_buttonToggles+(3*2)], 1
	jne RenderAnimation_DontResetFrame
		mov [word ptr rendering_animationFrame], nullword
	RenderAnimation_DontResetFrame:

	pop ax
	ret
endp RenderPreLoop

proc RenderBoard
	; Info: Renders the board onto the buffer. Not including blocks.
	push ax bx
	
	mov bx, boolTrue

	mov ax, 2
	push offset mask_boardborder 70 ax ax bx
	call BufferMaskCenter ; Render the border shadow

	xor ax, ax
	push offset mask_board 3 ax ax bx
	call BufferMaskCenter ; Render the board body
	
	push offset mask_boardstripes 2 ax ax bx
	call BufferMaskCenter ; Render the board stripes
	
	push offset mask_boardborder 4 ax ax bx
	call BufferMaskCenter ; Render the actual border


	pop bx ax
	ret
endp RenderBoard

proc RenderBlocks
	; Info: Renders the game blocks onto the buffer.
	push ax bx cx dx di si
	mov cx, 16 ;Iterations
	mov ax, 96 ;X
	mov dx, 36 ;Y
	xor bx, bx ;Row Counter
	
	
	push [word ptr listID_board] ;board list
	push bx ;we want just the offset, bx is already 0.
	call ListGet
	pop di ; List offset is here
	cmp [word ptr rendering_animationFrame], constant_animationTotalFrames
	jae RenderBlocks_DontCheckNull
		cmp [word ptr rendering_animationFrame], nullword
		jne RenderBlocks_Skip
	RenderBlocks_DontCheckNull:

	RenderBlocks_Loop:

		cmp [word ptr di], nullword
		je RenderBlocks_DontRender
			mov si, [word ptr di]
			shl si, 1 ;Multiply the type by 2, because each offset is a word.
			add si, offset internal_blockSpriteOffsets
			push [word ptr si] ax dx
			call BufferSprite
			cmp [word ptr game_mode], gamemodeDead
			jne RenderBlocks_DontRender
				push cx
				mov si, 16
				sub si, cx
				mov cx, si
				and cx, 11b ; the last 2 bits are the X
				shr si, 2 ;make the SI only Y
				add si, cx ; SI = X + Y, so we get that diagonal effect
				shl si, 5
				add si, constant_framesToShowStuckBlocks
				pop cx
				cmp [word ptr game_loseTimer], si
				jl RenderBlocks_DontRender
					mov si, offset sprite_stuckblock
					push si ax dx
					call BufferSprite
		RenderBlocks_DontRender:

		inc bl
		add ax, 32
		add di, 2
		cmp bl, 4
		jnz RenderBlocks_SkipNewRow
			sub ax, (32*4) ;Subtract the previous 4, to go back to the start of the row
			add dx, 32 ;Go to the new row
			xor bl, bl
		RenderBlocks_SkipNewRow:
		loop RenderBlocks_Loop
	
	RenderBlocks_Skip:
	pop si di dx cx bx ax
	ret
endp RenderBlocks

proc RenderShake
	; Info: Handles all the camera shake rendering/frame code.
	push ax bx cx dx di si
	
	; cmp [word ptr rendering_animationFrame], constant_mergeScreenshakeFrame
	; jne RenderShake_DontMergeShake
	cmp [byte ptr rendering_mergedScore], 2
	jb RenderShake_DontMergeShake
		; Merge Shake
		push 15 1 2
		call AnimationShake
		mov [byte ptr rendering_mergedScore], 0
	RenderShake_DontMergeShake:

	cmp [word ptr game_mode], gamemodeDead
	jne RenderShake_DontShakeStuck
		cmp [word ptr game_loseTimer], ((0*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		cmp [word ptr game_loseTimer], ((1*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		cmp [word ptr game_loseTimer], ((2*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		cmp [word ptr game_loseTimer], ((3*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		cmp [word ptr game_loseTimer], ((4*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		cmp [word ptr game_loseTimer], ((5*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		cmp [word ptr game_loseTimer], ((6*32)+constant_framesToShowStuckBlocks)
		je RenderShake_ShakeStuck
		
		jmp RenderShake_DontShakeStuck
		RenderShake_ShakeStuck:
			push 5 3 3
			call AnimationShake
	RenderShake_DontShakeStuck:


	; Shake Offset Code
	cmp [word ptr rendering_shake_framesLeft], nullword
	je RenderShake_Skip ; If there are no frames left, no need to do this
		xor bx, bx
		mov cx, [word ptr rendering_shake_strength] ; CX = Strength
		mov ax, cx
		shl ax, 1
		inc ax ; AX = Strength*2+1

		push bx ; minimum of 0
		push ax ; maximum of Strength*2+1 (because NumberRandom max is 1 lower)
		call NumberRandom
		pop [word ptr rendering_shake_xOffset]
		sub [word ptr rendering_shake_xOffset], cx

		push bx ; minimum of 0
		push ax ; maximum of Strength*2+1 (because NumberRandom max is 1 lower)
		call NumberRandom
		pop [word ptr rendering_shake_yOffset]
		sub [word ptr rendering_shake_yOffset], cx
		dec [word ptr rendering_shake_framesLeft]
		jnz RenderShake_Skip
		; Reached 0 here
			mov [word ptr rendering_shake_framesLeft], nullword
			mov [word ptr rendering_shake_xOffset], 0
			mov [word ptr rendering_shake_yOffset], 0
	RenderShake_Skip:
	pop si di dx cx bx ax
	ret
endp RenderShake

proc RenderAnimation
	; Info: Renders the block animation list to the buffer.
	push ax bx cx dx di si
	cmp [word ptr rendering_animationFrame], nullword
	je RenderAnimation_Finish
	cmp [word ptr rendering_animationFrame], constant_animationStopAtFrame

	jae RenderAnimation_ClearList ;If the frames match the total frames, animation is over and does not need to be displayed.
	
	push [word ptr listID_animation]
	push offset RenderAnimation_animationForeach
	push boolFalse
	call ListForeach ;Foreach On List 'animation'
	jmp RenderAnimation_animationForeachExit
	RenderAnimation_animationForeach:
	;DI = offset, CX = iterations left, AX = list element's length
		cmp [word ptr di], 0 ;Animation Type 0
		jne RenderAnimation_SkipType0
			jmp RenderAnimation_Type0
		RenderAnimation_SkipType0:
		cmp [word ptr di], 1 ;Animation Type 0
		jne RenderAnimation_SkipType1
			jmp RenderAnimation_Type1
		RenderAnimation_SkipType1:
		RenderAnimation_FinishType:
		ret
	RenderAnimation_animationForeachExit:
	inc [word ptr rendering_animationFrame]

	jmp RenderAnimation_Finish
		RenderAnimation_ClearList:
			; Here we need to clear the list of animation
			mov [word ptr rendering_animationFrame], nullword
			push [word ptr listID_animation]
			call ListClear
	RenderAnimation_Finish:
	pop si di dx cx bx ax
	ret
endp RenderAnimation

proc RenderAnimation_Type0
	cmp [word ptr rendering_animationFrame], constant_animationTotalFrames
	jae RenderAnimation_FinishType
	mov bx, [word ptr di+4]
	cmp bx, [word ptr di+8]
	je RenderAnimation_Type0_DontCurveX
		push bx ; If X moves
		push [word ptr di+8]
		push [word ptr rendering_animationFrame]
		call NumberCubicCurveCache ;Curve the X
		pop bx
		jmp RenderAnimation_Type0_CurvedX
	RenderAnimation_Type0_DontCurveX: ; If X doesn't move, multiply coordinate by 32
		shl bx, 5
	RenderAnimation_Type0_CurvedX:
	mov dx, [word ptr di+6]
	cmp dx, [word ptr di+10]
	je RenderAnimation_Type0_DontCurveY
		push dx ; If Y moves
		push [word ptr di+10]
		push [word ptr rendering_animationFrame]
		call NumberCubicCurveCache ;Curve the Y
		pop dx
		jmp RenderAnimation_Type0_CurvedY
	RenderAnimation_Type0_DontCurveY: ; If X doesn't move, multiply coordinate by 32
		shl dx, 5
	RenderAnimation_Type0_CurvedY:
	
	add bx, 96 ;X
	add dx, 36 ;Y

	mov si, [word ptr di+2] ; Block Type
	shl si, 1 ;Multiply the type by 2, because each offset is a word.
	push [word ptr si+internal_blockSpriteOffsets]
	push bx
	push dx
	call BufferSprite

	cmp [word ptr di+12], nullword ;Merge Data
	je RenderAnimation_Type0_NotMerge
		; This is a merge, we need to draw an extra on top of this
		push cx ; i need cx for this

		mov cx, [word ptr di+10] ; Intended Y
		shl cx, 5
		add cx, 36
		cmp [word ptr di+12], 0
		jne RenderAnimation_Type0_MergeNotDir0 ; Up
			add cx, 32
			jmp RenderAnimation_Type0_MergeNotDir2
		RenderAnimation_Type0_MergeNotDir0:
		cmp [word ptr di+12], 1
		je RenderAnimation_Type0_MergeNotDir2 ; Down
		mov cx, [word ptr di+8] ; Intended Y
		shl cx, 5
		add cx, 96
		cmp [word ptr di+12], 2
		jne RenderAnimation_Type0_MergeNotDir2 ; Left
			add cx, 32
		RenderAnimation_Type0_MergeNotDir2:

		mov si, [word ptr di+2] ; Block Type
		inc si
		shl si, 1 ;Multiply the type by 2, because each offset is a word.
		push [word ptr si+internal_blockSpriteOffsets]
		push bx
		push dx
		push cx ; Boundary Coordinate
		push [word ptr di+12] ; Direction
		call BufferSpriteBoundary

		pop cx ;pop it back out
	RenderAnimation_Type0_NotMerge:
	jmp RenderAnimation_FinishType
endp RenderAnimation_Type0

proc RenderAnimation_Type1
	
	push ax

	mov bx, [word ptr di+4]
	shl bx, 5
	add bx, 96 ;BX = X

	mov dx, [word ptr di+6]
	shl dx, 5
	add dx, 36 ;DX = Y

	mov si, [word ptr di+2] ; Block Type
	shl si, 1 ;Multiply the type by 2, because each offset is a word.

	cmp [word ptr rendering_animationFrame], 20
	jae RenderAnimation_Type1_ShowAnimation ;Below 20 frames, don't even show animation
		jmp RenderAnimation_Type1_DontBufferMask
	RenderAnimation_Type1_ShowAnimation:

	mov ax, offset mask_spawnanimation_tiny ;Stays 4 Frames
	
	cmp [word ptr rendering_animationFrame], (20+8)
	jb RenderAnimation_Type1_Finished
	mov ax, offset mask_spawnanimation_medium ;Stays 4 Frames

	cmp [word ptr rendering_animationFrame], (20+8+8)
	jb RenderAnimation_Type1_Finished
	mov ax, offset mask_spawnanimation_full ;Stays 4 Frames
	
	cmp [word ptr rendering_animationFrame], (20+8+8+8)
	jb RenderAnimation_Type1_Finished
	mov ax, offset mask_spawnanimation_half ;Stays 5 Frames
	call RenderAnimation_Type1_BufferMain ; Also sprite needs to buffer from this point on
	
	cmp [word ptr rendering_animationFrame], (20+8+8+8+10)
	jb RenderAnimation_Type1_Finished
	mov ax, offset mask_spawnanimation_outline ;Stays 8 Frames
	
	cmp [word ptr rendering_animationFrame], (20+8+8+8+10+16)
	ja RenderAnimation_Type1_DontBufferMask
	
	
	RenderAnimation_Type1_Finished:
	push ax
	push [word ptr si+rendering_blockSpawnColors]
	push bx
	push dx
	call BufferMask
	RenderAnimation_Type1_DontBufferMask:

	pop ax
	jmp RenderAnimation_FinishType

	
	RenderAnimation_Type1_BufferMain:
		push [word ptr si+internal_blockSpriteOffsets]
		push bx
		push dx
		call BufferSprite
		ret
endp RenderAnimation_Type1

proc RenderGameUI
	; Info: Renders the game UI - Mainly score.
	push ax bx cx dx di si
	mov ax, 242
	mov bx, 45
	mov si, 61
	
	push offset mask_ui_score_outline si ax bx ; Shadow
	call BufferMask
	dec ax
	dec bx

	mov si, 64
	push offset mask_ui_score_outline si ax bx ; Outline
	call BufferMask

	mov si, 67
	push offset mask_ui_score_main si ax bx ; Body
	call BufferMask

	mov di, 11
	push offset mask_ui_score_main di si ; Dither
	mov si, 65
	push si ax bx
	call BufferMaskDither

	push [word ptr game_score] offset internal_displayTest
	call NumberToString

	mov ax, 271
	mov bx, 67
	mov si, 2 ; Center
	xor di, di ; Style Parameter of 0
	push offset internal_displayTest
	push offset BufferStyle_ShadowOutlineDither di ;Style and Parameter
	push si ax bx ;Center, Top Left X & Y
	call BufferString

	call RenderButtons
	call RenderGameOverUI
	pop si di dx cx bx ax
	ret
endp RenderGameUI

proc RenderParticles
	; Info: Renders the particles to the screen buffer.
	push dx di si bx
	
	push [word ptr listID_particles] ; List ID
	push offset RenderParticles_Foreach
	push boolFalse
	call ListForeach
	jmp RenderParticles_ForeachExit
	RenderParticles_Foreach:
		push [word ptr game_rendercycles]
		push [word ptr di+6] ;checking the divisor
		call NumberMod
		pop si
		cmp si, 0
		jne RenderParticles_ForeachContinue
			inc [word ptr di]
			inc [word ptr di+2]
			cmp [word ptr di], 320 ;X border detection
			jl RenderParticles_DontWrapX
				sub [word ptr di], (320+100)
				jmp RenderParticles_NewStats
			RenderParticles_DontWrapX:
			cmp [word ptr di+2], 200 ;Y border detection
			jl RenderParticles_ForeachContinue
				sub [word ptr di+2], (200+100)
			RenderParticles_NewStats: ;New stats for the particle when it gets teleported
				push 0
				push 16
				call NumberRandom
				pop si
				mov [word ptr di + 4], si ; Type (0-2)
				push 30
				push 80
				call NumberRandom
				pop si
				mov [word ptr di + 6], si ; Render Cycles per Move (5-20)
		RenderParticles_ForeachContinue:
		mov bx, [word ptr di+4]
		shl bx, 1
		push [word ptr internal_backgroundMaskOffsets+bx] ;mask
		push 1 ;color
		push [word ptr di] ;x
		push [word ptr di+2] ;y
		call BufferMask
		ret
	RenderParticles_ForeachExit:

	pop bx si di dx
	ret
endp RenderParticles

proc RenderCursor
	; Info: Renders the mouse cursor.
	; Parameters: 
	;push ax bx
	cmp [byte ptr internal_movedMouse], boolFalse
	je RenderCursor_DontRender
	push offset sprite_cursor [word ptr internal_mouseX] [word ptr internal_mouseY]
	call BufferSprite

	RenderCursor_DontRender:
	;pop bx ax
	ret
endp RenderCursor

proc RenderButtons
	; Info: Renders all the buttons next to the board.
	push ax bx cx dx di si

	mov ax, 64 ; Button X
	mov bx, 46 ; Starting Button Y
	mov cx, constant_amountOfButtons ; Amt. of buttons
	mov di, 0
	RenderButtons_RenderLoop:
		mov si, 70
		push offset mask_button_shadow si ax bx
		call BufferMask ; Render the button shadow
		mov si, 3
		push offset mask_button_body si ax bx
		call BufferMask ; Render the button body
		mov si, 4
		push offset mask_button_border si ax bx
		call BufferMask ; Render the button border
		
		call RenderButtons_ButtonIcon

		dec ax ;bring back X to its original position
		add di, 2 ;Go to the next offset
		add bx, 29 ; go down 30 Y, but also decrease it by 1 since we increased it for the shadow
		loop RenderButtons_RenderLoop

	
	pop si di dx cx bx ax
	ret

	RenderButtons_ButtonIcon:
		mov si, 72
		mov dx, 71
		cmp [word ptr di+internal_activeMouseActions], boolFalse
		je RenderButtons_NotHighlighted
			mov si, 22
			mov dx, 21
		RenderButtons_NotHighlighted:
		push [di+internal_buttonIconOffsets] si ax bx ; icon
		inc ax
		inc bx
		push [di+internal_buttonIconOffsets] dx ax bx ; icon shadow, X and Y are displaced by 1
		call BufferMask ; Render the button icon shadow
		call BufferMask ; Render the button icon


		cmp [word ptr di+internal_buttonToggles], boolFalse
		je RenderButtons_NotToggled
			add ax, 2
			add bx, 4
			push offset sprite_button_x ax bx
			call BufferSprite
			sub ax, 2
			sub bx, 4
		RenderButtons_NotToggled:
		ret
endp RenderButtons

proc RenderGameOverUI
	cmp [word ptr rendering_gameOverFrame], 0
	jg RenderGameOverUI_ShowGameOver
		ret
	RenderGameOverUI_ShowGameOver:
	push ax bx cx dx di si
	; show the game over screen here
	mov si, 71 ; Color
	mov bx, 96 ; X
	mov cx, 36 ; Y
	mov di, [word ptr rendering_gameOverFrame]
	mov dx, 150
	sub dx, di
	neg di
	push dx 0
	call NumberMin
	pop dx
	push offset mask_icon_bigstart_shadow di si 3 bx cx
	call BufferMaskDither ; Render the shadow dither
	push offset mask_icon_bigstart_shadow dx si si bx cx
	call BufferMaskDither ; Render the shadow

	
	inc si ; SI = 72, the color of the body
	push offset mask_icon_bigrestart di si 71 bx cx
	call BufferMaskDither ; Render the body dither
	push offset mask_icon_bigrestart dx si si bx cx
	call BufferMaskDither ; Render the body
	pop si di dx cx bx ax
	ret
endp RenderGameOverUI



proc BufferClear
	; Info: Clears the screen buffer.
	push ax bx cx di es
	mov ax, ScreenBuffer
	mov es, ax ;ES is now at the screen buffer
	xor di, di
	mov cx, 32000
	xor ax, ax
	rep stosw
	pop es di cx bx ax
	ret
endp BufferClear

proc BufferRender
	; Info: Renders the Screen Buffer onto the video memory.
	push ax cx di ds si es

	mov ax, ScreenBuffer
	mov ds, ax ; DS is now at the screen buffer
	mov di, 0

	mov ax, 0A000h
	mov es, ax ; ES is now at the video memory
	mov si, 0

	mov cx, (320*200) ;We wanna iterate 64k times for every pixel

	rep movsb ;This does that shit

	pop es si ds di cx ax
	ret
endp BufferRender

proc BufferRect
	; Info: Renders a rectangle with a color (byte, lower half) onto the buffer.
	; Parameters: Color, Width, Height, Top Left X, Top Left Y
    push bp
    mov bp, sp
    push ax bx cx dx di si es
    color equ [word ptr bp + 12]
    rectWidth equ [word ptr bp + 10]
    rectHeight equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]

	mov ax, [word ptr rendering_shake_xOffset]
	add topLeftX, ax
	mov ax, [word ptr rendering_shake_yOffset]
	add topLeftY, ax

	mov ax, ScreenBuffer 
	mov es, ax ;Switch ES to the screen buffer.
    
	; Wrap Case - Fix Negative Top Left Coordinates
	mov ax, topLeftX
	cmp ax, 0
	jge BufferRect_WrapCaseX
		add rectWidth, ax
		mov topLeftX, 0
	BufferRect_WrapCaseX:

	mov ax, topLeftY
	cmp ax, 0
	jge BufferRect_WrapCaseY
		add rectHeight, ax
		mov topLeftY, 0
	BufferRect_WrapCaseY:

	; Clamp Case - Fix Width/Height Overflowing
	mov ax, 320
	sub ax, topLeftX
	cmp rectWidth, ax
	jle BufferRect_ClampCaseX
		mov rectWidth, ax
	BufferRect_ClampCaseX:
	
	mov ax, 200
	sub ax, topLeftY
	cmp rectHeight, ax
	jle BufferRect_ClampCaseY
		mov rectHeight, ax
	BufferRect_ClampCaseY:
    
	; Dead Case: Negative / Zero Width/Height
	cmp rectWidth, 0
	jle BufferRect_DeadCase
	cmp rectHeight, 0
	jle BufferRect_DeadCase

	; Full Case - Drawing the rect in its entirety.
	mov ax, 320
	imul topLeftY
	add ax, topLeftX
	mov di, ax ; DI = (320*y) + x
	mov bx, 320
	sub bx, rectWidth ; BX = 320 - Width
	
	mov ax, color ;we'll be using AL from now on
	mov cx, rectHeight

	BufferRect_RowLoop:
		push cx
		mov cx, rectWidth
		rep stosb
		add di, bx ;DI = DI + 320 - Width
		pop cx
		loop BufferRect_RowLoop

	BufferRect_DeadCase:
    pop es si di dx cx bx ax
    pop bp
	ret 10
endp BufferRect

proc BufferRectDither
	; Info: Renders a rectangle with a color (byte, lower half) and dither color (byte, lower half) onto the buffer.
	; Parameters: Rows to skip, AnchorX, AnchorY, Color1, Color2, Width, Height, Top Left X, Top Left Y
    push bp
    mov bp, sp
	sub sp, 2
    push ax bx cx dx di si es
    rowsToSkip equ [word ptr bp + 20]
    AnchorX equ [word ptr bp + 18]
    AnchorY equ [word ptr bp + 16]
    color1 equ [word ptr bp + 14]
    color2 equ [word ptr bp + 12]
    rectWidth equ [word ptr bp + 10]
    rectHeight equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]
    skipRowsOpposite equ [word ptr bp - 2]

	mov ax, [word ptr rendering_shake_xOffset]
	add topLeftX, ax
	mov ax, [word ptr rendering_shake_yOffset]
	add topLeftY, ax

	mov ax, ScreenBuffer 
	mov es, ax ;Switch ES to the screen buffer.
    
	; Wrap Case - Fix Negative Top Left Coordinates
	mov ax, topLeftX
	cmp ax, 0
	jge BufferRectDither_WrapCaseX
		add rectWidth, ax
		mov topLeftX, 0
	BufferRectDither_WrapCaseX:

	mov ax, topLeftY
	cmp ax, 0
	jge BufferRectDither_WrapCaseY
		add rectHeight, ax
		mov topLeftY, 0
	BufferRectDither_WrapCaseY:

	; Clamp Case - Fix Width/Height Overflowing
	mov ax, 320
	sub ax, topLeftX
	cmp rectWidth, ax
	jle BufferRectDither_ClampCaseX
		mov rectWidth, ax
	BufferRectDither_ClampCaseX:
	
	mov ax, 200
	sub ax, topLeftY
	cmp rectHeight, ax
	jle BufferRectDither_ClampCaseY
		mov rectHeight, ax
	BufferRectDither_ClampCaseY:
    
	; Dead Case: Negative / Zero Width/Height
	cmp rectWidth, 0
	jle BufferRectDither_DeadCase
	cmp rectHeight, 0
	jle BufferRectDither_DeadCase

	; Full Case - Drawing the rect in its entirety.
	mov ax, 320
	imul topLeftY
	add ax, topLeftX
	mov di, ax ; DI = (320*y) + x
	mov bx, 320
	sub bx, rectWidth ; BX = 320 - Width

	mov skipRowsOpposite, 0ffh
	
	mov ax, color1 ;we'll be using AL from now on
	mov dx, color2
	mov ah, dl ; higher half of ax is replaced with the lower half of dl, aka color2.
	mov cx, rectHeight
	mov dx, topLeftY
	sub dx, anchorY
	mov si, dx
	cmp rowsToSkip, 0
	jge BufferRectDither_SkipRowsNotReversed
		mov si, rowsToSkip
		neg si
		mov skipRowsOpposite, si
		mov si, dx
		neg si
	BufferRectDither_SkipRowsNotReversed:
	add dx, topLeftX
	sub dx, anchorX
	sar dx, 1 ;Divide by two, if carry flag is on that means it was an odd number
	jc BufferRectDither_InitialSwitch
		xor ah, al
		xor al, ah
		xor ah, al
	BufferRectDither_InitialSwitch:

	BufferRectDither_RowLoop:
		push cx
		
		cmp si, rowsToSkip
		jl BufferRectDither_SkipRow
		
		cmp si, skipRowsOpposite
		jg BufferRectDither_SkipRow


		mov cx, rectWidth
		sar cx, 1
		jc BufferRectDither_DrawExtra
			rep stosw
		BufferRectDither_DrawExtraFinish:
		pop cx
		call BufferRectDither_RowLoop_Iteration
		loop BufferRectDither_RowLoop

	BufferRectDither_DeadCase:
    pop es si di dx cx bx ax
	add sp, 2
    pop bp
	ret 18

	BufferRectDither_SkipRow:
		add di, rectWidth
		jmp BufferRectDither_DrawExtraFinish

	BufferRectDither_DrawExtra:
		cmp cx, 0
		je BufferRectDither_DontDrawExtra
			rep stosw
		BufferRectDither_DontDrawExtra:
		mov [byte ptr es:di], al
		;inc di
		inc di
		jmp BufferRectDither_DrawExtraFinish
	
	BufferRectDither_RowLoop_Iteration:
		add di, bx ;DI = DI + 320 - Width
		xor ah, al
		xor al, ah
		xor ah, al
		inc si
		cmp skipRowsOpposite, 0ffh
		je BufferRectDither_NotOpposite
			sub si, 2
		BufferRectDither_NotOpposite:
		ret

endp BufferRectDither

proc BufferMask
	; Info: Renders a mask, which is a collection of rects.
	; Parameters: Mask Offset, Color, TopLeftX, TopLeftY
    push bp
    mov bp, sp
    push ax bx cx dx di si
    maskOffset equ [word ptr bp + 10]
    color equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]
	mov di, maskOffset
	xor bx, bx
	mov bl, [byte ptr di] ;width
	add bx, topLeftX ; BX = X + Width
	cmp bx, 0
	jl BufferMask_SkipRender
	
	xor bh, bh
	mov bl, [byte ptr di + 1] ;height
	add bx, topLeftY ; BX = X + Width

	cmp bx, 0
	jl BufferMask_SkipRender

	cmp topLeftX, 320
	jge BufferMask_SkipRender
	
	cmp topLeftY, 200
	jge BufferMask_SkipRender

	mov cx, [word ptr di+2] ;Total Rects
	add di, 4
	xor ax, ax
	BufferMask_RectLoop:
		push color ;Rect Color

		mov al, [byte ptr di] ; Rect Width
		push ax
		mov al, [byte ptr di+1] ; Rect Height
		push ax

		mov al, [byte ptr di+2] ; X Offset
		add ax, topLeftX
		push ax
		xor ah, ah ; Reset the top part of AX

		mov al, [byte ptr di+3] ; Y Offset
		add ax, topLeftY
		push ax
		xor ah, ah ; Reset the top part of AX

		call BufferRect

		add di, 4
		loop BufferMask_RectLoop
	BufferMask_SkipRender:
    
    pop si di dx cx bx ax
    pop bp
	ret 8
endp BufferMask

proc BufferMaskDither
	; Info: Renders a mask, but with dither.
	; Parameters: Mask Offset, Rows to Skip, Color1, Color2, TopLeftX, TopLeftY
    push bp
    mov bp, sp
    push ax bx cx dx di si
    maskOffset equ [word ptr bp + 14]
	rowsToSkip equ [word ptr bp + 12]
    color1 equ [word ptr bp + 10]
    color2 equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]
	mov di, maskOffset
	xor bx, bx
	mov bl, [byte ptr di] ;width
	add bx, topLeftX ; BX = X + Width
	cmp bx, 0
	jl BufferMaskDither_SkipRender
	
	xor bh, bh
	mov bl, [byte ptr di + 1] ;height
	add bx, topLeftY ; BX = X + Width

	cmp bx, 0
	jl BufferMaskDither_SkipRender

	cmp topLeftX, 320
	jge BufferMaskDither_SkipRender
	
	cmp topLeftY, 200
	jge BufferMaskDither_SkipRender

	mov cx, [word ptr di+2] ;Total Rects
	;push cx [word ptr internal_totalRectMax]
	;call NumberMin
	;pop cx
	add di, 4
	xor ax, ax
	BufferMaskDither_RectLoop:
		push rowsToSkip topLeftX topLeftY ;Rows to skip, and anchors
		push color1 color2 ;Rect Color

		mov al, [byte ptr di] ; Rect Width
		push ax
		mov al, [byte ptr di+1] ; Rect Height
		push ax

		mov al, [byte ptr di+2] ; X Offset
		add ax, topLeftX
		push ax
		xor ah, ah ; Reset the top part of AX

		mov al, [byte ptr di+3] ; Y Offset
		add ax, topLeftY
		push ax
		xor ah, ah ; Reset the top part of AX

		call BufferRectDither

		add di, 4
		loop BufferMaskDither_RectLoop
	BufferMaskDither_SkipRender:
    
    pop si di dx cx bx ax
    pop bp
	ret 12
endp BufferMaskDither

proc BufferMaskWithStyle
	; Info: Buffers a mask with a style. If style is 0, will treat style parameter as color.
	; Parameters: Mask Offset, Style Offset, Style Parameter, Top left X, Top Left Y
    push bp
    mov bp, sp
    maskOffset equ [word ptr bp + 12]
    styleOffset equ [word ptr bp + 10]
    styleParameter equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]

	cmp styleOffset, 0
	jne BufferMaskWithStyle_NotZero
		mov styleOffset, offset BufferMask
	BufferMaskWithStyle_NotZero:

	push maskOffset styleParameter topLeftX topLeftY
	call styleOffset
    
	pop bp
	ret 10
endp BufferMaskWithStyle

proc BufferStyle_ShadowOutlineDither
	; Info: A Buffer style, used for rendering a body with an outline that has a shadow.
	; The outline mask offset should be stored in data right before the main mask.
	; Parameters: Mask Offset, Style Parameter, Top Left X, Top Left Y
    push bp
    mov bp, sp
    push ax bx si di
    maskOffset equ [word ptr bp + 10]
    styleParameter equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]

	mov di, maskOffset
	mov di, [word ptr di-2] ; DI = outline mask offset
	mov ax, topLeftX
	mov bx, topLeftY ;74, 75
	
	mov si, 62 ; Outline Shadow
	push di si ax bx
	call BufferMask

	dec ax
	dec bx

	mov si, 63 ; Outline
	push di si ax bx
	call BufferMask

	inc ax
	inc bx
	
	mov si, 66 ; Body
	push maskOffset si ax bx
	call BufferMask

	mov si, -6
	push maskOffset si ; Skip Rows
	mov si, 66 ; Dither Color1
	push si
	mov si, 68 ; Dither Color2
	push si ax bx
	call BufferMaskDither
    
    pop di si bx ax
    pop bp
	ret 8
endp BufferStyle_ShadowOutlineDither

proc BufferStyle_ShadowOutlineDitherProcedual
	; Info: A Buffer style, used for rendering a body with an outline that has a shadow.
	; This one does not require an extra mask offset.
	; Parameters: Mask Offset, Style Parameter, Top Left X, Top Left Y
    push bp
    mov bp, sp
    push ax bx si
    maskOffset equ [word ptr bp + 10]
    styleParameter equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]

	mov ax, topLeftX
	mov bx, topLeftY
	add ax, 2
	add bx, 2

	mov si, 62 ; Shadow
	push maskOffset si ax bx
	call BufferMask
	
	
	sub ax, 1
	sub bx, 2
	mov si, 63 ; Outline
	
	push maskOffset si ax bx
	call BufferMask
	
	sub ax, 2
	push maskOffset si ax bx
	call BufferMask

	inc ax
	inc bx
	push maskOffset si ax bx
	call BufferMask

	sub bx, 2
	push maskOffset si ax bx
	call BufferMask

	mov si, 66 ; Body
	push maskOffset si topLeftX topLeftY
	call BufferMask

	mov si, 68 ; Dithers

	push maskOffset 66 si topLeftX topLeftY
	call BufferMaskDither
    
    pop si bx ax
    pop bp
	ret 8
endp BufferStyle_ShadowOutlineDitherProcedual

proc BufferMaskCenter
	; Info: Renders a mask from its center. RelativeScreenPoint will make the coordinates 0,0 the screen's center.
	; Parameters: Mask Offset, Color, X Position, Y Position, ?RelativeToScreenCenter
	push bp
	mov bp, sp
	push ax bx cx dx di si
	maskOffset equ [word ptr bp + 12]
	color equ [word ptr bp + 10]
	xPosition equ [word ptr bp + 8]
	yPosition equ [word ptr bp + 6]
	relativeToScreenCenter equ [word ptr bp + 4]
	
	mov bx, maskOffset
	xor ax, ax
	; Calculate the top left X
	mov al, [byte ptr bx] ;AX = Mask Width
	shr al, 1 ;Divide AX by 2
	sub xPosition, ax ; xPosition -= (MaskWidth/2)
	mov al, [byte ptr bx+1] ;AX = Mask Height
	shr al, 1 ;Divide AX by 2
	sub yPosition, ax ; yPosition -= (MaskHeight/2)
	cmp relativeToScreenCenter, boolTrue
	jne BufferMaskCenter_RelativeToTopLeft
		add xPosition, 160
		add yPosition, 100
	BufferMaskCenter_RelativeToTopLeft:

	push maskOffset
	push color
	push xPosition
	push yPosition
	call BufferMask

	pop si di dx cx bx ax
	pop bp
	ret 10
endp BufferMaskCenter

proc BufferSprite
	; Info: Renders a sprite onto the buffer.
	; Parameters: Sprite Offset, Top Left X, Top Left Y
	push bp
	mov bp, sp
	sub sp, 4 ;Allocate some space for temporary variables
	push ax bx cx dx di es si

	spriteOffset equ [word ptr bp + 8]
	topLeftX equ [word ptr bp + 6]
	topLeftY equ [word ptr bp + 4]
	spriteWidth equ [word ptr bp - 2]
	spriteHeight equ [word ptr bp - 4]

	mov ax, [word ptr rendering_shake_xOffset]
	add topLeftX, ax
	mov ax, [word ptr rendering_shake_yOffset]
	add topLeftY, ax

	mov ax, topLeftY
	mov dx, 320
	imul dx
	add ax, topLeftX
	mov si, ax ;SI = (topLeftY * 320) + topLeftX

	mov ax, ScreenBuffer
	mov es, ax ; ES is now at the screen buffer

	mov di, spriteOffset

	mov cx, [word ptr di]
	mov spriteWidth, cx
	mov cx, [word ptr di+2]
	mov spriteHeight, cx
	mov cx, [word ptr di+4] ; CX = Sprite Type (Default, Transparency)

	add di, 6
	cmp cx, 1
	je BufferSprite_SafeVersion

	cmp topLeftX, 0
	jl BufferSprite_SafeVersion ;Safe buffer if X < 0
	
	mov ax, spriteWidth
	add ax, topLeftX
	cmp ax, 320
	jge BufferSprite_SafeVersion ;Safe buffer if Width < 320-x

	cmp topLeftY, 0
	jl BufferSprite_SafeVersion ;Safe buffer if Y < 0
	
	mov ax, spriteHeight
	add ax, topLeftY
	cmp ax, 200
	jge BufferSprite_SafeVersion ;Safe buffer if Height < 200-x
		; Unsafe Buffer, Faster but only works when full sprite is in frame.
		xor si, di
		xor di, si
		xor si, di ;XOR swapping SI and DI, since they work weirdly in movsb (DS:SI to ES:DI)
		mov bx, 320
		sub bx, spriteWidth ; BX = 320 - Width
		mov cx, spriteHeight
		BufferSprite_UnsafeRowLoop:
			push cx
			mov cx, spriteWidth
			rep movsb
			add di, bx ;DI = DI + 320 - Width
			pop cx
			loop BufferSprite_UnsafeRowLoop
		jmp BufferSprite_Exit ;quit early as to not buffer the safe way too

	BufferSprite_SafeVersion:


	mov cx, 0
	mov bx, 0
	BufferSprite_SetLoop:
		
		mov al, [byte ptr di]
		cmp al, nullbyte
		jz BufferSprite_SkipDraw
		
		mov dx, cx ;Whole DX part is for detecting if this sprite's width is overflowing
		add dx, topLeftX
		cmp dx, 320
		jge BufferSprite_SkipDraw
		cmp dx, 0
		jl BufferSprite_SkipDraw

		mov dx, bx ;Whole DX part is for detecting if this sprite's height is overflowing
		add dx, topLeftY
		cmp dx, 200
		jge BufferSprite_SkipDraw
		cmp dx, 0
		jl BufferSprite_SkipDraw

			mov [byte ptr es:si], al
			;dec [byte ptr es:si]
		BufferSprite_SkipDraw:

		inc si ;increase the screen offset
		inc di ;increase the sprite offset pointer
		inc cx ;just some row detection, cx being width and dx being height


		cmp cx, spriteWidth
		jl BufferSprite_AddWidth
			sub si, cx ;Take away the X si travelled, which is cx or spritewidth doesn't matter they're equal here
			add si, 320 ;Add a row to si
			mov cx, 0
			inc bx
			;cmp dx, 0
			;jl BufferSprite_Exit

			cmp bx, spriteHeight
			jl BufferSprite_SetLoop
			jmp BufferSprite_Exit
		BufferSprite_AddWidth:
		jmp BufferSprite_SetLoop
	BufferSprite_Exit:

	pop si es di dx cx bx ax
	add sp, 4
	pop bp
	ret 6
endp BufferSprite

proc BufferSpriteBoundary
	; Info: Renders a sprite onto the buffer.
	; Parameters: Sprite Offset, Top Left X, Top Left Y, Boundary Coordinate, Direction
	push bp
	mov bp, sp
	sub sp, 4 ;Allocate some space for temporary variables
	push ax bx cx dx di es si

	spriteOffset equ [word ptr bp + 12]
	topLeftX equ [word ptr bp + 10]
	topLeftY equ [word ptr bp + 8]
	boundaryCoordinate equ [word ptr bp + 6]
	direction equ [word ptr bp + 4]
	spriteWidth equ [word ptr bp - 2]
	spriteHeight equ [word ptr bp - 4]

	mov ax, [word ptr rendering_shake_xOffset]
	add topLeftX, ax
	mov ax, [word ptr rendering_shake_yOffset]
	add topLeftY, ax

	mov ax, topLeftY
	mov dx, 320
	imul dx
	add ax, topLeftX
	mov si, ax ;SI = (topLeftY * 320) + topLeftX

	mov ax, ScreenBuffer
	mov es, ax ; ES is now at the screen buffer

	mov di, spriteOffset

	mov cx, [word ptr di]
	mov spriteWidth, cx
	mov cx, [word ptr di+2]
	mov spriteHeight, cx
	mov cx, [word ptr di+4] ; CX = Sprite Type (Default, Transparency)
	add di, 6
	xor cx, cx
	xor bx, bx
	BufferSpriteBoundary_SetLoop:
		jmp BufferSpriteBoundary_SkipDrawTopOver
			BufferSpriteBoundary_SkipDrawTop:
				jmp BufferSpriteBoundary_SkipDraw
		BufferSpriteBoundary_SkipDrawTopOver:
		
		mov al, [byte ptr di]
		cmp al, nullbyte
		jz BufferSpriteBoundary_SkipDrawTop
		
		mov dx, cx ;Whole DX part is for detecting if this sprite's width is overflowing
		add dx, topLeftX
		cmp dx, 320
		jge BufferSpriteBoundary_SkipDrawTop
		cmp dx, 0
		jl BufferSpriteBoundary_SkipDrawTop

		cmp direction, 2 ;Direction Left
		jne BufferSpriteBoundary_SkipDirLeft
			cmp dx, boundaryCoordinate
			jge BufferSpriteBoundary_SkipDrawTop
		BufferSpriteBoundary_SkipDirLeft:

		cmp direction, 3 ;Direction Right
		jne BufferSpriteBoundary_SkipDirRight
			cmp dx, boundaryCoordinate
			jl BufferSpriteBoundary_SkipDrawTop
		BufferSpriteBoundary_SkipDirRight:

		mov dx, bx ;Whole DX part is for detecting if this sprite's height is overflowing
		add dx, topLeftY
		cmp dx, 200
		jge BufferSpriteBoundary_SkipDraw
		cmp dx, 0
		jl BufferSpriteBoundary_SkipDraw

		cmp direction, 0 ;Direction Up
		jne BufferSpriteBoundary_SkipDirUp
			cmp dx, boundaryCoordinate
			jge BufferSpriteBoundary_SkipDraw
		BufferSpriteBoundary_SkipDirUp:
		
		cmp direction, 1 ;Direction Down
		jne BufferSpriteBoundary_SkipDirDown
			cmp dx, boundaryCoordinate
			jl BufferSpriteBoundary_SkipDraw
		BufferSpriteBoundary_SkipDirDown:
		

			mov [byte ptr es:si], al
			;dec [byte ptr es:si]
		BufferSpriteBoundary_SkipDraw:

		inc si ;increase the screen offset
		inc di ;increase the sprite offset pointer
		inc cx ;just some row detection, cx being width and dx being height


		cmp cx, spriteWidth
		jl BufferSpriteBoundary_AddWidth
			sub si, cx ;Take away the X si travelled, which is cx or spritewidth doesn't matter they're equal here
			add si, 320 ;Add a row to si
			xor cx, cx
			inc bx ; Y

			cmp bx, spriteHeight
			jl BufferSpriteBoundary_SetLoop
			jmp BufferSpriteBoundary_Exit
		BufferSpriteBoundary_AddWidth:
		jmp BufferSpriteBoundary_SetLoop
	BufferSpriteBoundary_Exit:

	pop si es di dx cx bx ax
	add sp, 4
	pop bp
	ret 10
endp BufferSpriteBoundary

proc BufferSpriteCenter
	; Info: Renders a sprite to the buffer, anchored from its middle point. RelativeToScreenCenter will make the coordinates 0,0 the center of the screen.
	; Parameters: Sprite Offset, X Position, Y Position, ?RelativeToScreenCenter
	push bp
	mov bp, sp
	push ax bx cx dx di si
	spriteOffset equ [word ptr bp + 10]
	xPosition equ [word ptr bp + 8]
	yPosition equ [word ptr bp + 6]
	relativeToScreenCenter equ [word ptr bp + 4]
	
	mov bx, spriteOffset
	; Calculate the top left X
	mov ax, [bx] ;AX = Sprite Width
	shr ax, 1 ;Divide AX by 2
	sub xPosition, ax ; xPosition -= (SpriteWidth/2)
	mov ax, [bx+2] ;AX = Sprite Height
	shr ax, 1 ;Divide AX by 2
	sub yPosition, ax ; yPosition -= (SpriteHeight/2)
	cmp relativeToScreenCenter, boolTrue
	jne BufferSpriteCenter_RelativeToTopLeft
		add xPosition, 160
		add yPosition, 100
	BufferSpriteCenter_RelativeToTopLeft:

	push spriteOffset
	push xPosition
	push yPosition
	call BufferSprite

	pop si di dx cx bx ax
	pop bp
	ret 8
endp BufferSpriteCenter

proc BufferString
	; Info: Buffer a string from an offset. Will buffer till it hits a 0 byte.
	; Parameters: String Offset, Style Offset, Style Parameter, Alignment (0 - Left, 1 - Right, 2 - Center), Top Left X, Top Left Y
    push bp
    mov bp, sp
    push ax bx cx dx di si
    stringOffset equ [word ptr bp + 14]
    styleOffset equ [word ptr bp + 12]
    styleParameter equ [word ptr bp + 10]
    alignment equ [word ptr bp + 8]
    topLeftX equ [word ptr bp + 6]
    topLeftY equ [word ptr bp + 4]

	mov di, stringOffset
	mov ax, topLeftX
	xor bh, bh
	xor ch, ch
	cmp alignment, 0
	je BufferString_ReadLoop ; Alignment Left is normal, nothing needs to be done.
	push stringOffset
	call NumberGetStringLength ;Get the string length in pixels
	pop cx
	cmp alignment, 1
	je BufferString_AlignedRight
		shr cx, 1 ;half the offset we're adding
	BufferString_AlignedRight:
	sub ax, cx
	;mov si, topLeftY
	BufferString_ReadLoop:
		mov bl, [byte ptr di]
		cmp bl, 0
		je BufferString_ExitReadLoop
		shl bl, 1
		mov si, [word ptr internal_fontOffsets+bx]
		push si styleOffset styleParameter ax topLeftY
		call BufferMaskWithStyle
		mov cl, [byte ptr si]
		add ax, cx
		add ax, constant_characterSpacing
		inc di
	jmp BufferString_ReadLoop
	BufferString_ExitReadLoop:
	
    
    pop si di dx cx bx ax
    pop bp
	ret 12
	
	jmp BufferString_ReadLoop
endp BufferString




proc GameUpdateLoop
	; Info: Called every frame render.
	push ax bx cx dx di si
	;inc [word ptr internal_gameOverFrameAddCounter]
	cmp [word ptr game_mode], gamemodeDead ; are we dead boys
	jne GameUpdateLoop_NotDead ;naah
		cmp [word ptr game_loseTimer], (constant_framesToShowGameOver)
		jae GameUpdateLoop_DontAddLoseTimer
			inc [word ptr game_loseTimer]
			jmp GameUpdateLoop_DeadFinish
		GameUpdateLoop_DontAddLoseTimer:
		cmp [word ptr rendering_gameOverFrame], 200
		jge GameUpdateLoop_DeadFinish
			add [word ptr rendering_gameOverFrame], 2
		jmp GameUpdateLoop_DeadFinish
	GameUpdateLoop_NotDead:
	; Decrease from the frame
	;mov [word ptr internal_gameOverFrameAddCounter], 0
	cmp [word ptr rendering_gameOverFrame], 0
	jle GameUpdateLoop_DeadFinish
		sub [word ptr rendering_gameOverFrame], 3
		cmp [word ptr rendering_gameOverFrame], 0
		jge GameUpdateLoop_DeadFinish
			mov [word ptr rendering_gameOverFrame], 0
	GameUpdateLoop_DeadFinish:
	pop si di dx cx bx ax
	ret
endp GameUpdateLoop

proc GameSpawnBlock
	; Info: Spawns a game tile into the board list at a random null position.
	; Parameters: Tile Type
	push bp
	mov bp, sp
	push ax bx cx dx di si
	tileType equ [word ptr bp + 4]
	
	push [word ptr listID_boardAvailable]
	call ListClear

	push [word ptr listID_board]
	push offset GameSpawnBlock_boardForeach
	push boolTrue
	call ListForeach ;Foreach on list 'board'
	jmp GameSpawnBlock_boardForeachExit
	GameSpawnBlock_boardForeach:
		;DI = offset, CX = iterations left, AX = list element's length
		cmp [word ptr di], nullword
		jne GameSpawnBlock_NotNullSkip
			push [word ptr listID_boardAvailable] ; List ID
			call ListGetAdd ;Like list add but returns the offset
			pop bx ;We now got the add position
			mov [word ptr bx], 16
			sub [word ptr bx], cx ; Element = listIndex
		GameSpawnBlock_NotNullSkip:
		ret
	GameSpawnBlock_boardForeachExit:
	;jmp skiptest
	FinallyDecide:
	push [word ptr listID_boardAvailable]
	call ListCount
	pop bx
	; If bx = 0, no available spots, this would mean check for lose.
	; this also means i can't spawn any block, so i'll have to skip that.
	cmp bx, 0
	je GameSpawnBlock_CantSpawn

	push 0
	push bx ; List Count
	call NumberRandom
	pop si ; si = index

	push [word ptr listID_boardAvailable]
	push si
	call ListGet
	pop si
	
	mov di, [word ptr si] ; DI = Index
	

	push [word ptr listID_board]
	push di
	call ListGet
	pop bx

	mov ax, tileType
	mov [word ptr bx], ax
	; mov cl, al
	; mov dx, 2
	; shl dx, cl
	; add [word ptr game_score], dx

	mov si, di
	and si, 11b ; SI = X
	shr di, 2 ; DI = Y
	
	push 1 ; Animation Type (1 is Spawned Block)
	push tileType ; Block Type
	push si ; Start X
	push di ; Start Y
	push si ; End X
	push di ; End Y
	push nullword ; Merge Data
	call AnimationAdd

	GameSpawnBlock_CantSpawn:
	pop si di dx cx bx ax
	pop bp
	ret 2
endp GameSpawnBlock

proc GameSetBlock
	; Info: Spawns a game tile into the board list.
	; Parameters: Tile Type, Tile Index
	push bp
	mov bp, sp
	push ax bx
	tileType equ [word ptr bp + 6]
	tileIndex equ [word ptr bp + 4]
	
	push [word ptr listID_board]
	push tileIndex
	call ListGet
	pop bx
	mov ax, tileType
	mov [word ptr bx], ax


	pop bx ax
	pop bp
	ret 4
endp GameSetBlock

proc GameMove
	; Info: Moves the game board in a direction, and when two of the same type hit, calls the merging function.
	; Parameters: Direction (0-3)
    push bp
    mov bp, sp
    push ax bx cx dx di si
    direction equ [word ptr bp + 4]

	mov [byte ptr internal_shouldSpawnBlock], boolFalse
	mov [byte ptr rendering_mergedScore], 0

	push [word ptr listID_boardMerged]
	push boolFalse
	call ListSetAll

	mov [word ptr rendering_animationFrame], 0
	push [word ptr listID_animation]
	call ListClear

	xor ax, ax
	mov cx, 4
	GameMove_LinesLoop:
		push direction
		push ax ; ax is the line index, X
		call GameCollapseLine
		inc ax
		loop GameMove_LinesLoop
	
	xor bx, bx
	cmp [word ptr game_score], 500
	jb GameMove_CantSpawnFour ; can only spawn 4s above a score of 100
		push 0 20
		call NumberRandom
		pop ax
		cmp ax, 10
		ja GameMove_CantSpawnFour
		mov bx, 1 ;type 1 would be a 4
	GameMove_CantSpawnFour:
	; cmp [word ptr game_score], 500
	; jb GameMove_CantSpawnEight ; can only spawn 8s above a score of 500
	; 	push 0 20
	; 	call NumberRandom
	; 	pop ax
	; 	cmp ax, 5
	; 	ja GameMove_CantSpawnEight
	; 	mov bx, 2 ;type 2 would be an 8
	; GameMove_CantSpawnEight:
	cmp [byte ptr internal_shouldSpawnBlock], boolFalse
	je GameMove_DontSpawnBlock
		push bx
		call GameSpawnBlock
	GameMove_DontSpawnBlock:
	call GameCheckLose

    pop si di dx cx bx ax
    pop bp
	ret 2
endp GameMove

proc GameCollapseLine
	; Info: Collapses a line of blocks in the game board.
	; Parameters: Direction, Line Index
    push bp
    mov bp, sp
	sub sp, 4
    push ax bx cx dx di si
    direction equ [word ptr bp + 6]
    lineIndex equ [word ptr bp + 4]
	originalBlockOffset equ [word ptr bp - 2]
	originalY equ [word ptr bp - 4]

    
	; LineIndex = X = AX
	mov ax, lineIndex
	xor bx, bx ;Y = 0

	mov cx, 4
	GameCollapseLine_CheckBlockLoop: ;run through the column
		push direction
		call GameCalculateBoardOffset ; sets index to si
		mov dx, [word ptr si] ; DX is now the block type
		cmp dx, nullword
		je GameCollapseLine_CheckBlockSkip
			; Actual block
			mov originalBlockOffset, si ; originalBlockOffset is now set to BlockIndex+BoardListOffset
			mov originalY, bx
			push bx
			GameCollapseLine_CollapseBlock:
				; Looping through to collapse the block
				cmp bx, 0
				je GameCollapseLine_GotoBlockSettle ; If block reaches the top wall, settle.
				dec bx
				push direction
				call GameCalculateBoardIndex
				mov di, si ;Save DI as a copy of the index
				add di, [word ptr listOffset_boardMerged]
				shl si, 1 ; Every block is 2 bytes
				add si, [word ptr listOffset_board] ; SI is now the offset of the soon-to-be block
				cmp [word ptr si], nullword ; Compare newblock tp air, if so, jump
				je GameCollapseLine_CollapseBlock ; If it's air, go back to collapsing
				cmp [byte ptr di], boolTrue ; Check if it's already merged, using the merged board hash
				je GameCollapseLine_GotoBlockHitSettle ; Hit a block that was already merged.
				cmp dx, 10 ;Try to merge with a 2048
				je GameCollapseLine_GotoBlockHitSettle
				cmp [si], dx ; Compare newblock to old block
				je GameCollapseLine_GotoBlockMerge ; If newblock type = oldblock type, merge
				; Naturally go to BlockHitSettle, because newblock hit a block that doesn't share the same type
				jmp GameCollapseLine_GotoBlockHitSettle
				GameCollapseLine_GotoBlockHitSettle:
					jmp GameCollapseLine_BlockHitSettle
				GameCollapseLine_GotoBlockSettle:
					jmp GameCollapseLine_BlockSettle
				GameCollapseLine_GotoBlockMerge:
					jmp GameCollapseLine_BlockMerge
		GameCollapseLine_CheckBlockSkip:
		inc bx
		loop GameCollapseLine_CheckBlockLoop

    pop si di dx cx bx ax
	add sp, 4
    pop bp
	ret 4
endp GameCollapseLine

proc GameCollapseLine_SettleCases
	; Info: Extension for GameCollapseLine, Handles all the ways blocks can settle.
    direction equ [word ptr bp + 6]
    lineIndex equ [word ptr bp + 4]
	originalBlockOffset equ [word ptr bp - 2]
	originalY equ [word ptr bp - 4]

	GameCollapseLine_BlockHitSettle: ; When a block hits another block, but doesn't merge. activates before BlockSettle.
		inc bx ; Increase the Y, so it doesn't collapse ON the block it hit.
	GameCollapseLine_BlockSettle: ;When a block settles.
		; Animation Code
		push direction
		push 0 ; Animation Type (0 is Slide)
		push dx ; Block Type
		push ax ; Start X
		push originalY ; Start Y
		push ax ; End X
		push bx ; End Y
		push nullword
		call AnimationAddDirection

		cmp bx, originalY
		je GameCollapseLine_BlockSettle_NotMoved
			mov [byte ptr internal_shouldSpawnBlock], boolTrue
		GameCollapseLine_BlockSettle_NotMoved:

		mov si, originalBlockOffset
		mov [word ptr si], nullword ;Delete the old block
		push direction
		call GameCalculateBoardIndex ; SI = Index, per (AX,BX)
		shl si, 1 ; Every block is 2 bytes
		add si, [word ptr listOffset_board] ; SI is now the offset of the soon-to-be block
		mov [word ptr si], dx ; Set the new block to the type of the old block.
		jmp GameCollapseLine_CollapseFinished ; Make sure we don't accidentally merge
	GameCollapseLine_BlockMerge:  ;When a block merges with another block.
		; Animation Code
		push direction
		push 0 ; Animation Type (0 is Slide)
		push dx ; Block Type
		push ax ; Start X
		push originalY ; Start Y
		push ax ; End X
		push bx ; End Y
		push direction
		call AnimationAddDirection

		mov [byte ptr internal_shouldSpawnBlock], boolTrue
		inc [byte ptr rendering_mergedScore]
		cmp dx, 3 ; Combining INTO a 32+ should always shake
		jne GameCollapseLine_BlockMerge_DontShake
			add [byte ptr rendering_mergedScore], 100 ;merged += (type+1)
		GameCollapseLine_BlockMerge_DontShake:
		push cx ax
		mov cl, dl
		mov ax, 2
		shl ax, cl
		add [word ptr game_score], ax
		pop ax cx

		mov si, originalBlockOffset
		mov [word ptr si], nullword ; Delete the old block
		push direction
		call GameCalculateBoardIndex ; SI = Index, per (AX,BX)
		mov di, si
		add di, [word ptr listOffset_boardMerged]
		mov [byte ptr di], boolTrue ;Set the merge hash at this index to true.
		shl si, 1 ; Every block is 2 bytes
		add si, [word ptr listOffset_board] ; SI = New Block Offset
		inc dx ; Increase the type, since we're going up a level.
		mov [word ptr si], dx ;Set the merged block to the increased type.

	GameCollapseLine_CollapseFinished: ;When it's finished, we need to pop BX back out.
		pop bx
	jmp GameCollapseLine_CheckBlockSkip
endp GameCollapseLine_SettleCases

proc GameCheckLose
	; Info: Checks if the current board has no moves left. If so, sets the game mode accordingly.
    push ax bx cx dx di si
	mov cx, 16
	mov di, [word ptr listOffset_board]
	jmp GameCheckLose_RunLoop

	GameCheckLose_NotLose:
		jmp GameCheckLose_Return
	GameCheckLose_RunLoop:
		mov bx, 16
		sub bx, cx ; bx = iteration
		mov dx, [di] ; DX = tile type
		cmp dx, nullword ;If there's an empty block, there are available moves.
		je GameCheckLose_NotLose
		cmp dx, 10 ; If it's a 2048, do not count it
		je GameCheckLose_CantAdd1

		cmp bx, 4 ; if I<4, you can't subtract 4
		jb GameCheckLose_CantSub4
			cmp dx, [di-(4*2)] ; Checking if the block type matches an adjacent block type
			je GameCheckLose_NotLose
		GameCheckLose_CantSub4:
		
		cmp bx, 12 ; if I>=12, you can't add 4
		jae GameCheckLose_CantAdd4
			cmp dx, [di+(4*2)] ; Checking if the block type matches an adjacent block type
			je GameCheckLose_NotLose
		GameCheckLose_CantAdd4:
		
		and bx, 3 ;3 is 11b, meaning it'll mask only the first two bits.
		cmp bx, 0 ;If the first 2 bits are 00, this block is in the first column, so it can't go left.
		je GameCheckLose_CantSub1
			cmp dx, [di-(1*2)] ; Checking if the block type matches an adjacent block type
			je GameCheckLose_NotLose
		GameCheckLose_CantSub1:
		cmp bx, 3 ;If the first 2 bits are 11, this block is in the last column, so it can't go right.
		je GameCheckLose_CantAdd1
			cmp dx, [di+(1*2)] ; Checking if the block type matches an adjacent block type
			je GameCheckLose_NotLose
		GameCheckLose_CantAdd1:

		add di, 2 ;every block is 2 bytes
		loop GameCheckLose_RunLoop
	; Lose
	push gamemodeDead
	call GameSetMode


	GameCheckLose_Return:
    pop si di dx cx bx ax
	ret
endp GameCheckLose

proc GameSetMode
	; Info: Sets the game's mode, along with the proper initialization it requires.
	; Parameters: New Gamemode
    push bp
    mov bp, sp
    push ax bx cx dx di si
    newGamemode equ [word ptr bp + 4]
    mov ax, newGamemode
	cmp [word ptr game_mode], ax
	je GameSetMode_Ignore

	mov [word ptr game_loseTimer], 0
	cmp newGamemode, gamemodePlaying
	jne GameSetMode_NotPlaying
		; Set to playing
		call GameRestart
	GameSetMode_NotPlaying:

	cmp newGamemode, gamemodeMainMenu
	jne GameSetMode_NotMainMenu
		; Set to main menu
	GameSetMode_NotMainMenu:

	cmp newGamemode, gamemodeDead
	jne GameSetMode_NotDead
		; Set to dead
	GameSetMode_NotDead:

	cmp newGamemode, gamemodePause
	jne GameSetMode_NotPause
		; Set to pause.
	GameSetMode_NotPause:

	mov [word ptr game_mode], ax

	GameSetMode_Ignore:
    pop si di dx cx bx ax
    pop bp
	ret 2
endp GameSetMode

proc GameCalculateBoardIndex
	; Info: Calculates an index for the board via direction.
	; Registers: AX, BX, SI
	; Parameters: Direction, X (AX), Y (BX)
	; Returns: List Index (SI)
    push bp
    mov bp, sp
	push dx ax bx
    direction equ [word ptr bp + 4]
	mov dx, direction
	and dx, 1
	jz GameMove_NotDownRight
		; Down Code - Y=(Y-3)
		neg bx
		add bx, 3
	GameMove_NotDownRight:

	cmp direction, 2
	jb GameMove_NotLeftRight
		; Left Right Code - Swap around the registers.
		xor ax, bx
		xor bx, ax
		xor ax, bx
	GameMove_NotLeftRight:



	mov si, bx
	shl si, 2
	add si, ax

	pop bx ax dx
    pop bp
	ret 2
endp GameCalculateBoardIndex

proc GameCalculateBoardOffset
	; Info: Calculates an element offset for the board.
	; Registers: AX, BX, SI
	; Parameters: Direction, X (AX), Y (BX)
	; Returns: List Index (SI)
    push bp
    mov bp, sp
	push [word ptr bp + 4]
	call GameCalculateBoardIndex
	shl si, 1
	add si, [word ptr listOffset_board]
    pop bp
	ret 2
endp GameCalculateBoardOffset

proc GameRestart
	; Info: Restarts the played game.
	
	mov [word ptr game_mode], gamemodePlaying

	mov [word ptr game_score], 0
	call InitializeAnimation
	call InitializeBoard

	ret
endp GameRestart




proc InitializePalette
	; Info: Initializes the palette
	mov si, offset rendering_palette
	mov cx, 256
	mov dx, 3C8h
	mov al, 0
	out dx, al
	inc dx
	InitializePalette_PalLoop:
		mov al, [byte ptr si] ; Red
		shr al, 2
		out dx, al ; Send Red
		mov al, [byte ptr si + 1] ; Green
		shr al, 2
		out dx, al ; Send Green
		mov al, [byte ptr si + 2] ; Blue
		shr al, 2
		out dx, al ; Send Blue
		add si, 3
		loop InitializePalette_PalLoop
	ret
endp InitializePalette

proc InitializeParticles
	; Info: Initializes particles
	push ax bx cx dx di si

	cmp [word ptr listID_particles], nullword ;If the particles list is null
	jnz InitializeParticles_DontCreateList
		;Creating the list here
		push 8 ;Particles need PX, PY, VX, VY
		push 20 ;Particle Amount, I only need 20 particles at once
		call ListCreate
		pop [word ptr listID_particles] ; List ID
	InitializeParticles_DontCreateList:

	push [word ptr listID_particles]
	push offset InitializeParticles_particlesForeach
	push boolTrue
	call ListForeach ;Foreach On List 'particles'
	jmp InitializeParticles_particlesForeachExit
	InitializeParticles_particlesForeach:
	;DI = offset, CX = iterations left, AX = list element's length
		push ax
		push 0
		push (320+100)
		call NumberRandom
		pop ax
		sub ax, 100
		mov [word ptr di], ax ; Position X
		push 0
		push (200+100)
		call NumberRandom
		pop ax
		sub ax, 100
		mov [word ptr di + 2], ax ; Position Y
		push 0
		push 16
		call NumberRandom
		pop ax
		mov [word ptr di + 4], ax ; Type
		push 30
		push 80
		call NumberRandom
		pop ax
		mov [word ptr di + 6], ax ; Render Cycles per Move (5-20)
		pop ax
		ret
	InitializeParticles_particlesForeachExit:
	
	push [word ptr listID_particles]
	push nullword
	call ListSetCount
	
	pop si di dx cx bx ax
	ret
endp InitializeParticles

proc InitializeBoard
	; Info: Initializes the board variables
	push ax bx cx dx di si
	cmp [word ptr listID_board], nullword ;If the board list is null
	jnz InitializeBoard_DontCreateListBoard
		;Creating the list here
		push 2 ;Every board tile needs a type, that's it, only 2.
		push 16 ;Board is 4x4 - 16 tiles.
		call ListCreate
		pop [word ptr listID_board] ; List ID

		push [word ptr listID_board]
		push 0
		call ListGet
		pop [word ptr listOffset_board] ;board offset

		push 2 
		push 16 	
		call ListCreate ;Creating the same list as board, that hosts the indices that are available to spawn on
		pop [word ptr listID_boardAvailable] ; List ID
		
		push 1 
		push 16 	
		call ListCreate ;Creating a 16 byte list, that hosts a hash of the board indices that were merged on
		pop [word ptr listID_boardMerged] ; List ID

		push [word ptr listID_boardMerged]
		push 0
		call ListGet
		pop [word ptr listOffset_boardMerged] ;board offset
	InitializeBoard_DontCreateListBoard:
	
	push [word ptr listID_board]
	call ListClear
	push [word ptr listID_boardAvailable]
	call ListClear

	xor ax, ax
	mov [word ptr game_score], ax
	; Start with 2 blocks.
	mov [word ptr rendering_animationFrame], ax
	push ax
	call GameSpawnBlock
	push ax
	call GameSpawnBlock

	pop si di dx cx bx ax
	ret
endp InitializeBoard

proc InitializeInternal
	; Info: Initializes all the necessary internal variables.
	push ax bx cx dx di si
	mov ax, offset lists_alloc
	mov [word ptr lists_offset], ax
	pop si di dx cx bx ax
	ret
endp InitializeInternal

proc InitializeInteractions
	; Info: Initializes all the interaction-based things - key actions, mouse actions, etc.
	push ax bx cx dx di si

	mov ax,0h
	int 33h ; Activate mouse cursor input
	
	mov ax,2h
	int 33h ; Hide the mouse cursor

	mov ax,1ah
	mov bx, 30
	mov cx, 30
	mov dx, 40h
	int 33h ; Set mouse sensitivity

	call InitializeKeyActions
	call InitializeAllMouseActions

	pop si di dx cx bx ax
	ret
endp InitializeInteractions

proc InitializeAllMouseActions
	; Info: Initializes all mouse actions.
	push bx si

	push offset MouseAction_GameRestart 64 (46+(0*30)) 87 (69+(0*30))
	call InitializeMouseAction
	push offset MouseAction_GameMainMenu 64 (46+(1*30)) 87 (69+(1*30))
	call InitializeMouseAction
	push offset MouseAction_GameShakeToggle 64 (46+(2*30)) 87 (69+(2*30))
	call InitializeMouseAction
	push offset MouseAction_GameAnimationToggle 64 (46+(3*30)) 87 (69+(3*30))
	call InitializeMouseAction
	
	push offset MouseAction_Board 96 56 (96+128) (56+128)
	call InitializeMouseAction

	pop si bx
	ret
endp InitializeAllMouseActions

proc InitializeMouseAction
	; Info: Initializes a mouse action, increasing the pointer and adding it to the recognized list.
	; Parameters: Procedure Offset, Boundary Top Left X, Boundary Top Left Y, Boundary Bottom Right X, Boundary Bottom Right Y
    push bp
    mov bp, sp
    push ax bx cx dx di si
    procedureOffset equ [word ptr bp + 12]
    boundaryTopLeftX equ [word ptr bp + 10]
    boundaryTopLeftY equ [word ptr bp + 8]
    boundaryBottomRightX equ [word ptr bp + 6]
    boundaryBottomRightY equ [word ptr bp + 4]

	mov di, [word ptr internal_mouseActionsPointer]
	shl di, 1
	mov cx, di
	shl di, 2
	add di, cx ; DI = MousePointer * 10
	inc [word ptr internal_mouseActionsPointer]
	add di, offset internal_mouseActions
	mov ax, procedureOffset
	mov [di], ax
	mov ax, boundaryTopLeftX
	mov [di+2], ax
	mov ax, boundaryTopLeftY
	mov [di+4], ax
	mov ax, boundaryBottomRightX
	mov [di+6], ax
	mov ax, boundaryBottomRightY
	mov [di+8], ax
    
	pop si di dx cx bx ax
	pop bp
	ret 10
endp InitializeMouseAction

proc InitializeKeyActions
	; Info: Initializes all the key actions.
	push bx si
	mov si, offset internal_keyActions
	mov bl, 0 ;Game Move
		mov bh, 0 ;Direction Up
		 mov [(11h * 2) + si], bx ; 'W'
		 mov [(48h * 2) + si], bx ; Up Arrow
		mov bh, 1 ;Direction Down
		 mov [(1fh * 2) + si], bx ; 'S'
		 mov [(50h * 2) + si], bx ; Down Arrow
		mov bh, 2 ;Direction Left
		 mov [(1eh * 2) + si], bx ; 'A'
		 mov [(4bh * 2) + si], bx ; Left Arrow
		mov bh, 3 ;Direction Left
		 mov [(20h * 2) + si], bx ; 'D'
		 mov [(4dh * 2) + si], bx ; Right Arrow
	mov bl, 1 ;Cheat
		mov bh, 3 ;Spawn '16' Block
		 mov [(2eh * 2) + si], bx ; 'C'
	mov bx, 2 ;Break
		 mov [(30h * 2) + si], bx ; 'B'
	mov bx, 3 ;Restart
		 mov [(13h * 2) + si], bx ; 'R'
		 
	pop si bx
	ret
endp InitializeKeyActions

proc InitializeAnimation
	; Info: Initializes the necessary variables for block animations.
    push ax bx cx dx di si
	cmp [word ptr listID_animation], nullword ;If the animation list is null
	jnz InitializeAnimation_DontCreateList
		;Creating the list here
		push 14 ; AnimType, BlockType, XStart, YStart, XEnd, YEnd, MergeData
		push 24 ;Board is 16 tiles, so max 16 animations. but 20 for safety.
		call ListCreate
		pop [word ptr listID_animation] ; List ID

		push [word ptr listID_animation]
		push 0
		call ListGet
		pop [word ptr listOffset_animation] ;animation offset

		push 1 
		push 16 	
		call ListCreate ;Creating a 16 byte list, that hosts a hash of the board indices that are currently animated
		pop [word ptr listID_boardAnimation] ; List ID

		push [word ptr listID_boardAnimation]
		push 0
		call ListGet
		pop [word ptr listOffset_boardAnimation] ;board offset
	InitializeAnimation_DontCreateList:
	
	mov [word ptr rendering_animationFrame], nullword
	push [word ptr listID_animation]
	call ListClear

	xor ah, ah
	mov al, nullbyte
	push [word ptr listID_boardAnimation]
	push ax
	call ListSetAll

    pop si di dx cx bx ax
	ret
endp InitializeAnimation

proc InitializeCurve
	; Info: Initializes the internal_curveCache, so that animation doesn't have to use costy math.
	push ax bx cx dx di si
	
	mov di, offset internal_curveCache
	mov cx, 4
	InitializeCurve_NSLoop:
		mov bx, 4
		sub bx, cx ; BX = NS
		push cx
		xor ax, ax ; AX = NE
		mov cx, 3
		InitializeCurve_NELoop:
			cmp ax, bx
			jne InitializeCurve_NotMatching
				inc ax
			InitializeCurve_NotMatching:
			; Here we iterate through all 64 frames
			push cx
			mov cx, 64
			xor si, si
				InitializeCurve_FrameLoop:
				push bx ax si ; NStart, NEnd, Frame
				call NumberCubicCurve
				pop dx
				cmp bx, ax
				jb InitializeCurve_NGoesUp
					; N Goes Down, Need to add 1
					
				InitializeCurve_NGoesUp:
				mov [byte ptr di], dl
				inc di
				inc si
				loop InitializeCurve_FrameLoop
			pop cx
			inc ax
			loop InitializeCurve_NELoop
		pop cx
		loop InitializeCurve_NSLoop

	pop si di dx cx bx ax
	ret
endp InitializeCurve





proc AnimationAdd
	; Info: Adds a block animation to the global list.
	; Parameters: Animation Type, Block Type, X Start, Y Start, X End, Y End, Merge Data
    push bp
    mov bp, sp
    push bx di

	push [word ptr listID_animation]
	call ListGetAdd
	pop di
	mov bx, [word ptr bp + 16]
	mov [di], bx
	mov bx, [word ptr bp + 14]
	mov [di+2], bx
	mov bx, [word ptr bp + 12]
	mov [di+4], bx
	mov bx, [word ptr bp + 10]
	mov [di+6], bx
	mov bx, [word ptr bp + 8]
	mov [di+8], bx
	mov bx, [word ptr bp + 6]
	mov [di+10], bx
	mov bx, [word ptr bp + 4]
	mov [di+12], bx
    
	pop di bx
	pop bp
	ret 14
endp AnimationAdd

proc AnimationAddDirection
	; Info: Adds a block animation to the global list, provided with a direction (0-3)
	; Parameters: Direction, Animation Type, Block Type, X Start, Y Start, X End, Y End, Merge Data
    push bp
    mov bp, sp
    push ax bx cx dx di si
	direction equ [word ptr bp + 18]

	mov ax, [word ptr bp + 12] ; X Start
	mov cx, [word ptr bp + 10] ; Y Start
	mov dx, [word ptr bp + 8] ; X End
	mov si, [word ptr bp + 6] ; Y End

	mov bx, direction
	and bx, 1
	jz AnimationAddDirection_NotDownRight
		; Down Code - Y=(Y-3)
		neg cx
		add cx, 3
		neg si
		add si, 3
	AnimationAddDirection_NotDownRight:

	cmp direction, 2
	jb AnimationAddDirection_NotLeftRight
		; Left Right Code - Swap around the registers.
		xor ax, cx
		xor cx, ax
		xor ax, cx

		xor dx, si
		xor si, dx
		xor dx, si
	AnimationAddDirection_NotLeftRight:

	push [word ptr listID_animation]
	call ListGetAdd
	pop di
	mov bx, [word ptr bp + 16]
	mov [di], bx
	mov bx, [word ptr bp + 14]
	mov [di+2], bx
	mov [di+4], ax
	mov [di+6], cx
	mov [di+8], dx
	mov [di+10], si
	mov bx, [word ptr bp + 4]
	mov [di+12], bx
    
	pop si di dx cx bx ax
	pop bp
	ret 16
endp AnimationAddDirection

proc AnimationShake
	; Info: Shakes the camera for a specific duration, with other parameters.
	; Parameters: Frame Duration, Strength, Priority
    push bp
    mov bp, sp
    push ax
    frameDuration equ [word ptr bp + 8]
    strength equ [word ptr bp + 6]
	priority equ [word ptr bp + 4]

	cmp [word ptr internal_buttonToggles+(2*2)], 1
	je AnimationShake_DontSet

	cmp [word ptr rendering_shake_framesLeft], nullword
	je AnimationShake_DontCheckPriority
		; Compare priorities, if lower than the current one, don't change the camerashake variables.
		mov ax, priority
		cmp [word ptr rendering_shake_priority], ax
		ja AnimationShake_DontSet ; if oldpriority>newpriority, don't set
	AnimationShake_DontCheckPriority:
	
	mov ax, frameDuration
	mov [word ptr rendering_shake_framesLeft], ax
	mov ax, priority
	mov [word ptr rendering_shake_priority], ax
	mov ax, strength
	mov [word ptr rendering_shake_strength], ax
    
	AnimationShake_DontSet:
    pop ax
    pop bp
	ret 6
endp AnimationShake




proc MainProcessKey
	; Info: Processes a key pressed by the player.
	; Parameters: ScanCode
    push bp
    mov bp, sp
    push ax bx cx dx di si
    scanCode equ [word ptr bp + 4]
	xor ax, ax
	xor cx, cx
	xor dx, dx
	xor di, di
	xor si, si ;reset all my registers just for fun :)
	mov bx, scanCode
	shl bx, 1
	mov bx, [word ptr bx + internal_keyActions] ; bx is now the key action
	cmp bx, nullword
	je MainProcessKey_Finish
		; Mode-Specific Actions
		cmp [word ptr game_mode], gamemodeMainMenu
		jne MainProcessKey_SkipMainMenu
			jmp MainProcessKey_MainMenu
			MainProcessKey_SkipMainMenu:
		cmp [word ptr game_mode], gamemodePlaying
		jne MainProcessKey_SkipPlaying
			jmp MainProcessKey_Playing
			MainProcessKey_SkipPlaying:
		cmp [word ptr game_mode], gamemodeDead
		jne MainProcessKey_SkipDead
			jmp MainProcessKey_Dead
			MainProcessKey_SkipDead:
		cmp [word ptr game_mode], gamemodePause
		jne MainProcessKey_FinishModeActions
			jmp MainProcessKey_Pause
		MainProcessKey_FinishModeActions:

		; Universal Actions
		cmp bl, 1
		je MainProcessKey_Cheat
		cmp bl, 2
		je MainProcessKey_Break
		cmp bl, 3
		je MainProcessKey_Restart
    MainProcessKey_Finish:
    pop si di dx cx bx ax
    pop bp
	ret 2
	MainProcessKey_Cheat: ; BL=1, BH=Block Type
		mov cl, bh ; Block Type
		push cx
		call GameSpawnBlock
		;dec [word ptr internal_totalRectMax]
		jmp MainProcessKey_Finish
	MainProcessKey_Break: ; BL=2, BH=
		;inc [word ptr internal_totalRectMax]
		push gamemodeDead
		call GameSetMode
		call Break
		jmp MainProcessKey_Finish
	MainProcessKey_Restart: ; BL=3, BH=None
		call GameRestart
		jmp MainProcessKey_Finish

endp MainProcessKey

proc MainProcessKey_MainMenu
	; Info: Processes a key pressed by the player, in the main menu.
	; BL = Action Type, BH = Parameter, Any other registers are free to use.

	jmp MainProcessKey_FinishModeActions ; Return
endp MainProcessKey_MainMenu

proc MainProcessKey_Playing
	; Info: Processes a key pressed by the player, while in-game.
	; BL = Action Type, BH = Parameter, Any other registers are free to use.
	cmp bl, 0
	je MainProcessKey_GameMove

	jmp MainProcessKey_FinishModeActions ; Return

	MainProcessKey_GameMove: ; BL=0, BH=Move Direction
		mov cl, bh ; Move Direction
		push cx
		call GameMove
		jmp MainProcessKey_Finish
endp MainProcessKey_Playing

proc MainProcessKey_Pause
	; Info: Processes a key pressed by the player, in the pause menu.
	; BL = Action Type, BH = Parameter, Any other registers are free to use.

	jmp MainProcessKey_FinishModeActions ; Return
endp MainProcessKey_Pause

proc MainProcessKey_Dead
	; Info: Processes a key pressed by the player, while dead.
	; BL = Action Type, BH = Parameter, Any other registers are free to use.

	jmp MainProcessKey_FinishModeActions ; Return
endp MainProcessKey_Dead

proc MainProcessMouse
	; Info: Processes the mouse inputs, calling necessary mouse actions.
	push di si ax

	shr cx, 1 ;CX needs to divide by 2
	mov ax, cx

	push ax
	push [word ptr internal_mouseX]

	mov [word ptr internal_mouseX], ax
	mov [word ptr internal_mouseY], dx

	pop ax ; ax = old internalmousex
	cmp [byte ptr internal_movedMouse], boolTrue
	je MainProcessMouse_AlreadyMoved
		cmp ax, nullword
		je MainProcessMouse_AlreadyMoved ; if it's null we can't really know yet
		cmp [word ptr internal_mouseX], ax 
		je MainProcessMouse_AlreadyMoved ; if it's the same as the old version, it didn't move
		mov [byte ptr internal_movedMouse], boolTrue
	MainProcessMouse_AlreadyMoved:
	; pop ax ; ax goes back to being shifted cx
	; 		removing these two because they cancel out.
	; push ax ; pushed back right here
	mov al, [byte ptr internal_mouseLeftClick]
	mov [byte ptr internal_mouseLeftClick], 0
	mov [byte ptr internal_mouseLeftClickFirst], 0
	shr bx, 1
	jnc MainProcessMouse_LeftClickSkip
		cmp al, 1
		mov [byte ptr internal_mouseLeftClick], 1 ; This'll add 1 if left clicked
		je MainProcessMouse_LeftClickSkip
		mov [byte ptr internal_mouseLeftClickFirst], 1
	MainProcessMouse_LeftClickSkip:

	mov al, [byte ptr internal_mouseRightClick]
	mov [byte ptr internal_mouseRightClick], 0
	mov [byte ptr internal_mouseRightClickFirst], 0
	shr bx, 1
	jnc MainProcessMouse_RightClickSkip
		cmp al, 1
		mov [byte ptr internal_mouseRightClick], 1 ; This'll add 1 if Right clicked
		je MainProcessMouse_RightClickSkip
		mov [byte ptr internal_mouseRightClickFirst], 1
	MainProcessMouse_RightClickSkip:
	pop ax


	mov cx, [word ptr internal_mouseActionsPointer]
	mov di, offset internal_mouseActions
	mov si, offset internal_activeMouseActions
	MainProcessMouse_CheckLoop:
		cmp ax, [di+2] ; Top Left X
		jb MainProcessMouse_CheckFalse
		cmp dx, [di+4] ; Top Left Y
		jb MainProcessMouse_CheckFalse
		cmp ax, [di+6] ; Bottom Right X
		ja MainProcessMouse_CheckFalse
		cmp dx, [di+8] ; Bottom Right Y
		ja MainProcessMouse_CheckFalse
		
		; Check is true
		mov [word ptr si], boolTrue

		cmp [word ptr di], nullword
		je MainProcessMouse_NoProcedureOffset
			call [word ptr di] ; call the function offset
		MainProcessMouse_NoProcedureOffset:
		
		add di, 10
		add si, 2
	loop MainProcessMouse_CheckLoop

	pop ax si di
	ret

	MainProcessMouse_CheckFalse:
		mov [word ptr si], boolFalse
		jmp MainProcessMouse_NoProcedureOffset

endp MainProcessMouse

proc MouseAction_GameRestart
	; Info: Called when the Game Restart button is hovered.
	cmp [byte ptr internal_mouseLeftClickFirst], boolTrue
	jne MouseAction_GameRestart_NotClicking
		; Restart
		call GameRestart
	MouseAction_GameRestart_NotClicking:
	ret
endp MouseAction_GameRestart

proc MouseAction_GameMainMenu
	; Info: Called when the Game Main Menu button is hovered.
	cmp [byte ptr internal_mouseLeftClickFirst], boolTrue
	jne MouseAction_GameMainMenu_NotClicking
		; Main Menu
		push gamemodeMainMenu
		call GameSetMode
	MouseAction_GameMainMenu_NotClicking:
	ret
endp MouseAction_GameMainMenu

proc MouseAction_GameShakeToggle
	; Info: Called when the Game Shake Toggle button is hovered.
	cmp [byte ptr internal_mouseLeftClickFirst], boolTrue
	jne MouseAction_GameShakeToggle_NotClicking
		; Shake Toggle
		xor [word ptr internal_buttonToggles + (2*2)], 1b ;switch the first bit on and off.
		jnz MouseAction_GameShakeToggle_ToggledOn ; If toggled on, no need to activate the next part.
			; If toggled off, we shake a lil bit just to show the animation off lol
			push 40 2 5 ;duration, strength, priority
			call AnimationShake
			jmp MouseAction_GameShakeToggle_NotClicking
		MouseAction_GameShakeToggle_ToggledOn:
			mov [word ptr rendering_shake_xOffset], 0
			mov [word ptr rendering_shake_yOffset], 0
	MouseAction_GameShakeToggle_NotClicking:
	ret
endp MouseAction_GameShakeToggle

proc MouseAction_GameAnimationToggle
	; Info: Called when the Game Animation Toggle button is hovered.
	cmp [byte ptr internal_mouseLeftClickFirst], boolTrue
	jne MouseAction_GameAnimationToggle_NotClicking
		; Shake Toggle
		xor [word ptr internal_buttonToggles + (3*2)], 1b ;switch the first bit on and off.
		jz MouseAction_GameAnimationToggle_NotClicking ; If toggled on, no need to activate the next part.
			; If toggled on, clear all the current animations.
			call InitializeAnimation
	MouseAction_GameAnimationToggle_NotClicking:
	ret
endp MouseAction_GameAnimationToggle

proc MouseAction_Board
	; Info: Called when the game board is hovered.
	cmp [word ptr game_mode], gamemodeDead
	jne MouseAction_Board_NoRestartButton
		cmp [word ptr rendering_gameOverFrame], 120
		jb MouseAction_Board_NoRestartButton
			cmp [byte ptr internal_mouseLeftClickFirst], boolTrue
			jne MouseAction_Board_NoRestartButton
				; Restart
				call GameRestart
	MouseAction_Board_NoRestartButton:
	ret
endp MouseAction_Board



proc Break
	ret
endp Break



start:
	mov ax, @data
	mov ds, ax

	
	; Initialization

	call InitializeInternal

	mov ax, 13h
	int 10h

	call InitializeInteractions
	call InitializePalette
	call InitializeParticles
	call InitializeAnimation
	call InitializeCurve
	call InitializeBoard


	xor ax, ax
	xor bx, bx

	GameLoop:
	mov ah, 1h
	int 16h
	jz GameLoopCheckMouse ;skip if key isn't pressed
		mov ah, 0h
		int 16h
		cmp al, 'q'
		je exit
		mov bl, ah ;move the scancode over to bx's lower half
		push bx
		call MainProcessKey
		jmp GameLoop
	GameLoopCheckMouse:
		mov ax,3h
		int 33h
		call MainProcessMouse
		xor ax, ax
		xor bx, bx
		call RenderScreen
		call BufferRender
		call GameUpdateLoop
		jmp GameLoop

exit:
	mov ax, 4c00h
	int 21h
END start
